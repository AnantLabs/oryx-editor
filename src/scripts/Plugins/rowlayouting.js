/** *  * @author jan-felix.schwarz@student.hpi.uni-potsdam.de * */if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.RowLayouting = Clazz.extend({	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		// Initialize variables				this.currentShapes = [];			// Current selected Shapes		this.toMoveShapes = [];				// Shapes that are moved			this.faktorXY = {x:1, y:1};		//this.dragBounds = undefined;		this.offset = {x:0, y:0};		this.facade.registerEventType('layout.rows');		this.facade.registerOnEvent('layout.rows', this.handleLayoutRows.bind(this));			},			/**	 * On the Selection-Changed	 *	 */	onSelectionChanged: function(event) {				var elements = event.elements;		// If there are no elements		if(!elements || elements.length == 0) {			// reset all variables			this.currentShapes = [];			this.toMoveShapes = [];			this.dragBounds = undefined;		} else {			// Set the current Shapes			this.currentShapes = elements;			// Get all shapes with the highest parent in object hierarchy (canvas is the top most parent)			this.toMoveShapes = this.facade.getCanvas().getShapesWithSharedParent(elements);						this.toMoveShapes = this.toMoveShapes.findAll( function(shape) { return shape instanceof ORYX.Core.Node && 																			(shape.dockers.length === 0 || !elements.member(shape.dockers.first().getDockedShape()))});				/*			// Calculate the area-bounds of the selection			var newBounds = undefined;			elements.each(function(value) {				if(!newBounds)					newBounds = value.absoluteBounds();				else					newBounds.include(value.absoluteBounds());			});			// Set the new bounds			this.dragBounds = newBounds;		*/		}		return;	},		/**	 * On Layout Rows	 *	 */	handleLayoutRows: function(event) {				var marginLeft = event.marginLeft;		var marginTop = event.marginTop;		var spacingX = event.spacingX;		var spacingY = event.spacingY;		var elements = event.shape.getChildShapes(false);				// exclude specified stencils from layouting		if(event.exclude) {			elements = elements.filter(function(element) {			return ! event.exclude.some(function(value){return element.getStencil().id()==value;}) });		}				var rowTop = marginTop;		var rowBottom = marginTop - spacingY;				// Sort top-down		elements = elements.sortBy(function(element) {						return element.bounds.upperLeft().y;					});				var insertRowOffset = 0;		var deleteRowOffset = 0;		var isNewRow = false;				var movedShapes = this.toMoveShapes;				// Assign shapes to rows		elements.each(function(element) {						var ul = element.bounds.upperLeft();			var lr = element.bounds.lowerRight();						// save old values			var oldUlX = ul.x; var oldUlY = ul.y; var oldLrX = lr.x; var oldLrY = lr.y;						if(movedShapes.include(element)) {				ul.y -= deleteRowOffset;								if((ul.y > rowBottom) || ((element==elements.first()) && ul.y < marginTop)) {					// ul.y < marginTop wird bei nebeneinander nach oben verschobenen shapes					// mehrmals erfŸllt, dadurch mehrmals neue row und untereinanderrutschen					// -> nur falls erstes element										// next row					isNewRow = false;					rowTop = rowBottom + spacingY;					if(ul.y < rowTop) {						// insert new row						insertRowOffset += element.bounds.height();						isNewRow = true;					}				}			} else {				ul.y += insertRowOffset;								if(ul.y > rowTop) {					// next row					isNewRow = false;					rowTop = rowBottom + spacingY;				}			}						// align shape at row top			ul.y = rowTop;			lr.y = ul.y + element.bounds.height();						if (lr.y > rowBottom) {				// extend row height and inserted rows offset				if(isNewRow) insertRowOffset += lr.y - rowBottom;				else if(movedShapes.include(element)) insertRowOffset += lr.y - rowBottom;				rowBottom = lr.y;			}						if( (ul.x!=oldUlX) || (ul.y!=oldUlY) ||(lr.x!=oldLrX) || (lr.y!=oldLrY) ) {				// only set bounds if ul or lr updated				if(!movedShapes.include(element)) {					// if non-moved elements are repositioned upwards also move following moved elements upwards					// (otherwise dropping the moved element to a row below wouldn't work correctly)					if((oldUlY-ul.y) > deleteRowOffset) deleteRowOffset = oldUlY - ul.y;				}				element.bounds.set(ul.x, ul.y, lr.x, lr.y);			}		});				// Sort top-down from left to right		elements = elements.sortBy(function(element) {						return element.bounds.upperLeft().y * 10000 + element.bounds.upperLeft().x;					});							rowTop = marginTop;		var rowRight = marginLeft - spacingX;		var maxRowRight = rowRight;				// Arrange shapes on rows (align left)		elements.each(function(element) {						var ul = element.bounds.upperLeft();			var lr = element.bounds.lowerRight();						// save old values			var oldUlX = ul.x; var oldUlY = ul.y; var oldLrX = lr.x; var oldLrY = lr.y;						if(ul.y > rowTop) {				// next row				rowTop = ul.y;				rowRight = marginLeft - spacingX;			}						// align at right border of the row			ul.x = rowRight + spacingX;			lr.x = ul.x + element.bounds.width();			rowRight = lr.x;			if(rowRight>maxRowRight) maxRowRight = rowRight;						if( (ul.x!=oldUlX) || (ul.y!=oldUlY) ||(lr.x!=oldLrX) || (lr.y!=oldLrY) ) {				// only set bounds if ul or lr updated				element.bounds.set(ul.x, ul.y, lr.x, lr.y);			}					});				// if not root element update parent's bounds				if(event.shape!=this.facade.getCanvas()) {			var ul = event.shape.bounds.upperLeft();			if(maxRowRight>marginLeft)				event.shape.bounds.set(ul.x, ul.y, ul.x + maxRowRight + marginLeft, ul.y + rowBottom + marginTop);			}				this.facade.updateSelection();		return;	}	});