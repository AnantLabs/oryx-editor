/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}if(!ORYX.Core.Math) {ORYX.Core.Math = {};}	ORYX.Core.Math.midPoint = function(point1, point2) {	return 	{				x: Math.min(point1.x, point2.x) + ((Math.max(point1.x, point2.x) - Math.min(point1.x, point2.x)) / 2.0),				y: Math.min(point1.y, point2.y) + ((Math.max(point1.y, point2.y) - Math.min(point1.y, point2.y)) / 2.0)			}				}			/** * Get a boolean if the point is in the polygone * @param {point} * @param {line} Is a hashmap with point1, point2 * @param {offset} optional */ORYX.Core.Math.isPointInLine = function (point, line, offset) {	offset = offset ? Math.abs(offset) : 1;	var p1 = line.point1;	var p2 = line.point2;		if(p1.x == p2.x && Math.abs(point.x - p1.x) < offset && point.y < Math.max(p1.y, p2.y) && point.y > Math.min(p1.y, p2.y)) {		return true	}	if(p1.y == p2.y && Math.abs(point.y - p1.y) < offset && point.x < Math.max(p1.x, p2.x) && point.x > Math.min(p1.x, p2.x)) {		return true	}	if(point.x > Math.max(p1.x, p2.x) || point.x < Math.min(p1.x, p2.x)) {		return false	}	if(point.y > Math.max(p1.y, p2.y) || point.y < Math.min(p1.y, p2.y)) {		return false	}				var s = (p1.y - p2.y) / (p1.x - p2.x);	var b = p1.y - s * p1.x;			var calcY = (s * point.x) + b		return 	Math.abs(point.y - calcY) < offset}/** * Get a boolean if the point is in the polygone * @param {point} * @param {elipse} Is a hashmap with x, y, radiusX, radiusY */ORYX.Core.Math.isPointInEllipse = function (point, elipse) {	if(!elipse.x || !elipse.y || !elipse.radiusX || !elipse.radiusY) {		throw "ORYX.Core.Math.isPointInEllipse needs a ellipse with these properties: x, y, radiusX, radiusY"	}	var distance = Math.sqrt(									(Math.pow(point.x - elipse.x, 2) / Math.pow(elipse.radiusX, 2)) 								+ 	(Math.pow(point.y - elipse.y, 2) / Math.pow(elipse.radiusY, 2))							)		return 	distance <= 1	}	/** * Get a boolean if the point is in the polygone * @param {point} * @param {[points]} Cornerpoints of the Polygone */ORYX.Core.Math.isPointInPolygone = function (point, polygone) {		if(arguments.length != 2) { throw "ORYX.Core.Math.isPointInPolygone needs two arguments" }		var points = polygone;			if(points.first() != points.last())		points.push(points.first());							  	var angle = ORYX.Core.Math.arcTan2ofPoints(		points.first().x,		points.first().y,        point.x,		point.y,		points.last().x,		points.last().y);	for(var i = 0; i <= points.length - 2; i++) {		angle = angle + ORYX.Core.Math.arcTan2ofPoints(			points[i].x,			points[i].y,	        point.x,			point.y,			points[i+1].x,			points[i+1].y);	}		 	return Math.abs(angle) > 0.000001;}	/** * Calculates the dot product */ORYX.Core.Math.dotProduct = function(ax, ay, bx, by, cx, cy){  		var Bax = ax - bx;  		var Bay = ay - by;  		var Bcx = cx - bx;  		var Bcy = cy - by;	return (Bax * Bcx) + (Bay * Bcy);		}/** * Calculates the cross product */ORYX.Core.Math.crossProduct = function(ax, ay, bx, by, cx, cy){  		var Bax = ax - bx;  		var Bay = ay - by;  		var Bcx = cx - bx;  		var Bcy = cy - by;	return (Bax * Bcy) - (Bay * Bcx);		}	/** * Calculates the arc tangens of three points */ORYX.Core.Math.arcTan2ofPoints = function (ax, ay, bx, by, cx, cy) {		var dp = ORYX.Core.Math.dotProduct(ax,ay,bx,by,cx,cy);	var cp = ORYX.Core.Math.crossProduct(ax,ay,bx,by,cx,cy);	return Math.atan2(cp,dp);}