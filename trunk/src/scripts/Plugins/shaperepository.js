/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins) {	ORYX.Plugins = new Object();}ORYX.Plugins.ShapeRepository = {	facade: undefined,	construct: function(facade) {		this.facade = facade;		this.currentParent;/* Ext 1.1 code. Replaced by Ext 2.0.				var node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml",			null,			['div']);		var childNode = ORYX.Editor.graft("http://www.w3.org/1999/xhtml",			node,			['div']);		// Create a new Layout 		var layout = this.facade.getLayout();		layout.addRegion('west',{	                        split:true,	                        initialSize: 170,	                        minSize: 120,	                        maxSize: 250,	                        titlebar: true,	                        collapsible: true,                            animate: true,							useShim:true,							autoScroll:true	                    });				// Add a new Content panel in there		layout.beginUpdate();		layout.add('west', new Ext.ContentPanel(node, {title: 'Shape Repository', fitToFrame:true}));		layout.endUpdate();		// Hide the horizontal scrollbar		layout.getRegion('west').bodyEl.dom.style.overflowX = "hidden";		// Create a new Tree-Panel and add to the Layout	    var ctree = new Ext.tree.TreePanel(childNode, {	        animate:true,	        enableDD:false,	        containerScroll: true,	        lines:false,	        rootVisible:false,	        loader: new Ext.tree.TreeLoader()	    });				// Create a Root-Node		this.shapeList = new Ext.tree.TreeNode({			allowDrag:false,        	allowDrop:false,        	text:'ShapeRepository'});			    ctree.setRootNode(this.shapeList);	    ctree.render();		this.shapeList.expand();				*/ 		this.shapeList = new Ext.tree.TreeNode({					})		var panel = new Ext.tree.TreePanel({			width: 170,			border: false,			autoScroll:true,			loader: new Ext.tree.TreeLoader(),			root: this.shapeList,			rootVisible: false,			lines: false		})		var region = this.facade.addToRegion("west", panel, "Shape Repository");					// Create a Drag-Zone for Drag'n'Drop		var DragZone = new Ext.dd.DragZone(this.shapeList.getUI().getEl(), {shadow: !Ext.isMac});		DragZone.afterDragDrop = this.drop.bind(this, DragZone);		DragZone.beforeDragOver = this.beforeDragOver.bind(this, DragZone);		DragZone.beforeDragEnter = function(){this._lastOverElement = false; return true}.bind(this);				// Load all Stencilssets		this.setStencilSets()		this.facade.registerOnEvent("stencilSetLoaded", this.setStencilSets.bind(this));	},			/**	 * Load all stencilsets in the shaperepository	 */	setStencilSets: function() {		// Remove all childs		var child = this.shapeList.firstChild;		while(child) {			this.shapeList.removeChild(child);			child = this.shapeList.firstChild;		}		// Go thru all Stencilsets and stencils		this.facade.getStencilSets().values().each((function(sset) {						// For each Stencilset create and add a new Tree-Node			var stencilSetNode			this.shapeList.appendChild(stencilSetNode = new Ext.tree.TreeNode({				text:sset.title(), 			// Stencilset Name				allowDrag:false,        		allowDrop:false,           				iconCls:'headerShapeRepImg',	            cls:'headerShapeRep',				singleClickExpand:true}));						stencilSetNode.render();			stencilSetNode.expand();							// Get Stencils from Stencilset			var stencils = sset.stencils(this.facade.getCanvas().getStencil(),										 this.facade.getRules());				var treeGroups = new Hash();						// For each stencil			stencils.each((function(value) {								// Get the groups name				var groups = value.groups();								// For each Group-Entree				groups.each((function(group) {										// If there is a new group					if(!treeGroups[group]) {						// Create a new group						treeGroups[group] = new Ext.tree.TreeNode({							text:group,					// Group-Name							allowDrag:false,        					allowDrop:false,            							iconCls:'headerShapeRepImg', // Css-Class for Icon				            cls:'headerShapeRepChild',  // CSS-Class for Stencil-Group							singleClickExpand:true});												// Add the Group to the ShapeRepository						stencilSetNode.appendChild(treeGroups[group]);						treeGroups[group].render();						}										// Create the Stencil-Tree-Node					this.createStencilTreeNode(treeGroups[group], value);										}).bind(this));												// If there is no group				if(groups.length == 0) {					// Create the Stencil-Tree-Node					this.createStencilTreeNode(stencilSetNode, value);										}				}).bind(this));		}).bind(this));					},	createStencilTreeNode: function(parentTreeNode, stencil) {		// Create and add the Stencil to the Group		var newElement = new Ext.tree.TreeNode({				text:		stencil.title(), 		// Text of the stencil				icon:		stencil.icon(),			// Icon of the stencil				allowDrag:	false,					// Don't use the Drag and Drop of Ext-Tree				allowDrop:	false,				iconCls:	'ShapeRepEntreeImg', 	// CSS-Class for Icon				cls:		'ShapeRepEntree',		// CSS-Class for the Tree-Entree				});		parentTreeNode.appendChild(newElement);				newElement.render();							var ui = newElement.getUI();				// Set the tooltip		ui.elNode.setAttributeNS(null, "title", stencil.description());				// Register the Stencil on Drag and Drop		Ext.dd.Registry.register(ui.elNode, {				node: 		ui.node,		        handles: 	[ui.elNode, ui.textNode].concat($A(ui.elNode.childNodes)), // Set the Handles		        isHandle: 	false,				type:		stencil.id(),			// Set Type of stencil 				namespace:	stencil.namespace()		// Set Namespace of stencil				});									},		drop: function(dragZone, target, event) {				this._lastOverElement = undefined;				// Hide the highlighting		this.facade.raiseEvent({type: 'highlight.hideHighlight', highlightId:'shapeRepo.added'});		this.facade.raiseEvent({type: 'highlight.hideHighlight', highlightId:'shapeRepo.attached'});				// Check if drop is allowed		var proxy = dragZone.getProxy()		if(proxy.dropStatus == proxy.dropNotAllowed) { return }				// Check if there is a current Parent		if(!this._currentParent) { return }				var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);				var xy = event.getXY();		var pos = {x: xy[0], y: xy[1]};		var a = this.facade.getCanvas().node.getScreenCTM();		// Correcting the UpperLeft-Offset		pos.x -= a.e; pos.y -= a.f;		// Correcting the Zoom-Faktor		pos.x /= a.a; pos.y /= a.d;		// Correting the ScrollOffset		pos.x -= document.documentElement.scrollLeft;		pos.y -= document.documentElement.scrollTop;		// Correct position of parent		var parentAbs = this._currentParent.absoluteXY();		pos.x -= parentAbs.x;		pos.y -= parentAbs.y;		// Set position		option['position'] = pos				// Set parent		if( this._isAttachingAllowed &&  this._currentParent instanceof ORYX.Core.Node ){			option['parent'] = undefined;			} else {			option['parent'] = this._currentParent;		}				// Add a new Shape		var newShape = this.facade.createShape(option);		if( this._isAttachingAllowed &&  this._currentParent instanceof ORYX.Core.Node && newShape.dockers.length > 0){												var position 	= this.facade.eventCoordinates( event.browserEvent );							var docker = newShape.dockers[0];			if( docker.parent instanceof ORYX.Core.Node ) {				this._currentParent.parent.add( docker.parent );			}										docker.bounds.centerMoveTo( position )							docker.setDockedShape( this._currentParent );									this.facade.getCanvas().update();					}		this._currentParent.update();		this.facade.updateSelection();				this._currentParent = undefined;	},	beforeDragOver: function(dragZone, target, event){		var coord = this.facade.eventCoordinates(event.browserEvent);		var aShapes = this.facade.getCanvas().getAbstractShapesAtPosition(coord);		if(aShapes.length <= 0) {							var pr = dragZone.getProxy();				pr.setStatus(pr.dropNotAllowed);				pr.sync();								return false;		}					var el = aShapes.last();				if(aShapes.lenght == 1 && aShapes[0] instanceof ORYX.Core.Canvas) {						return false;					} else {			// check containment rules			var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);			var stencilSet = this.facade.getStencilSets()[option.namespace];			var stencil = stencilSet.stencil(option.type);			if(stencil.type() === "node") {				var parentCandidates = this.facade.getCanvas().getAbstractShapesAtPosition(coord);					var parentCandidate = parentCandidates.reverse().find(function(candidate) {					return (candidate instanceof ORYX.Core.Canvas || candidate instanceof ORYX.Core.Node);				});								if(parentCandidate) {					//check containment rule										this._isAttachingAllowed	= this.facade.getRules().canConnect({														sourceShape:	parentCandidate, 														edgeStencil:	stencil, 														targetStencil:	stencil														});											this._isAttachingAllowed	= this._isAttachingAllowed && parentCandidate.isPointOverOffset( coord );										if( !this._isAttachingAllowed ){						var canContain = this.facade.getRules().canContain({containingShape:parentCandidate, containedStencil:stencil})						this.facade.raiseEvent({														type:		'highlight.showHighlight', 														highlightId:'shapeRepo.added',														elements:	[parentCandidate],														color:		canContain ? ORYX.CONFIG.SELECTION_VALID_COLOR : ORYX.CONFIG.SELECTION_INVALID_COLOR													});							this.facade.raiseEvent({														type: 		"highlight.hideHighlight",														highlightId:"shapeRepo.attached"													});																																			} else {												this.facade.raiseEvent({												type: 			"highlight.showHighlight",												highlightId: 	"shapeRepo.attached",												elements: 		[parentCandidate],												style: 			ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,												color: 			ORYX.CONFIG.SELECTION_VALID_COLOR											});						this.facade.raiseEvent({												type: 			"highlight.hideHighlight",												highlightId: 	"shapeRepo.added"											});											}																this._currentParent = canContain || this._isAttachingAllowed ? parentCandidate : undefined;											var pr = dragZone.getProxy();					pr.setStatus(this._currentParent ? pr.dropAllowed : pr.dropNotAllowed );					pr.sync();					}			} else { //Edge				this._currentParent = this.facade.getCanvas();				var pr = dragZone.getProxy();				pr.setStatus(pr.dropAllowed);				pr.sync();			}				}				this._lastOverElement = el;				return false	}	}ORYX.Plugins.ShapeRepository = Clazz.extend(ORYX.Plugins.ShapeRepository);