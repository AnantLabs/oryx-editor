/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.Edit = Clazz.extend({	facade: undefined,	construct: function(facade) {		this.facade = facade;		this.copyElements = [];		this.facade.offer({			'name':"Cut",			'functionality': this.editCut.bind(this),			'group': "Edit",			'icon': ORYX.PATH + "images/cut.png",			'description': "Cut",			'index': 1,			'minShape': 1});		this.facade.offer({			'name':"Copy",			'functionality': this.editCopy.bind(this),			'group': "Edit",			'icon': ORYX.PATH + "images/page_copy.png",			'description': "Copy",			'index': 2,			'minShape': 1});		this.facade.offer({			'name':"Paste",			'functionality': this.editPaste.bind(this),			'group': "Edit",			'icon': ORYX.PATH + "images/page_paste.png",			'description': "Paste",			'index': 3,			'minShape': 0,			'maxShape': 0,			'isEnabled': (function(){return this.copyElements.length > 0}).bind(this)});		this.facade.offer({			'name':"Delete",			'functionality': this.editDelete.bind(this),			'group': "Edit",			'icon': ORYX.PATH + "images/cross.png",			'description': "Delete",			'index': 4,			'minShape': 1});		this.facade.registerOnEvent('keydown', this.keyHandler.bind(this));	},	keyHandler: function(event) {		var TastenCode = null;		if (!event)			event = window.event;		if (event.which) {			TastenCode = event.which;		} else if (event.keyCode) {			TastenCode = event.keyCode;		}		var modifierKeyPressed = event.ctrlKey;		if(modifierKeyPressed && this.facade.getSelection().length > 0) {			switch(TastenCode) {				case ORYX.CONFIG.KEY_Code_x:					this.editCut();					break;				case ORYX.CONFIG.KEY_Code_c:					this.editCopy();					break;			}		}		// Paste		if(modifierKeyPressed && TastenCode == ORYX.CONFIG.KEY_Code_v) {			this.editPaste();		}		// Delete		if(TastenCode == ORYX.CONFIG.KEY_Code_delete) {			this.editDelete();		}	},	editCut: function() {		this.editCopy(true);		this.editDelete(true);		return false;	},	editCopy: function(will_not_update) {		this.copyElements = [];		this.facade.getSelection().each((function(value) {				var serialize = value.serialize();				this.copyElements.push(serialize);		}).bind(this));				if(!will_not_update)			this.facade.updateSelection();	},	editPaste: function() {						var newElements = [];		this.copyElements.each((function(value) {				// Create the new Shape				var newShape = this.facade.createShape({serialize: value});								this.facade.getCanvas().add(newShape);								newShape.bounds.moveBy(ORYX.CONFIG.EDIT_OFFSET_PASTE,ORYX.CONFIG.EDIT_OFFSET_PASTE);				// Update				newShape.update();				newElements.push(newShape);		}).bind(this));		this.facade.setSelection(newElements);	},	editDelete: function(will_not_ask) {		var elements = this.facade.getSelection();		if(elements.length > 0) {			var ask_remove = will_not_ask === true || confirm( "Do you really want to delete the selected shape" + ((elements.length == 1) ? "": "s") + "?");			if(ask_remove)			{				elements.each((function(shape) {					this.facade.deleteShape(shape);				}).bind(this));				this.facade.setSelection([]);			}		}			}});