/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/var idCounter = 0;var ID_PREFIX = "resource";/** * Main initialization method. To be called when loading * of the document, including all scripts, is completed. */function init() {	/* When the blank image url is not set programatically to a local	 * representation, a spacer gif on the site of ext is loaded from the	 * internet. This causes problems when internet or the ext site are not	 * available. */	Ext.BLANK_IMAGE_URL = ORYX.PATH + 'lib/ext-2.0.2/resources/images/default/s.gif';			ORYX.Log.debug("Querying editor instances");	// Hack for WebKit to set the SVGElement-Classes	ORYX.Editor.setMissingClasses()	// render editor instances whereever there is an oryx canvas.	// TODO This should definately have predicate set!	DataManager.query(		undefined,		undefined,		{type: ERDF.RESOURCE, value: 'http://oryx-editor.org/canvas'}).each(					function(c) {				var anchor = c.subject.value;				var id = anchor.substring(1, anchor.length);				ORYX.Log.trace("Initializing instance #%0.", id);				new ORYX.Editor(id);				ORYX.Log.trace("Finished Initializing instance #%0.", id);			});}/** * Init namespaces */if(!ORYX) {var ORYX = {};}/** * The Editor class. */ORYX.Editor = {	/**	 * Constructor.	 */	construct: function(id) {		ORYX.Log.debug("Constructing Editor %0", this.id);		// initialization.		this._eventsQueue = [];		this.loadedPlugins = [];		this.pluginsData = [];		this.selection = [];		this.zoomLevel = 1.0;		this.movedDrag = undefined;		this.id = id;		this.ss_extensions_def;		var canvasStencil;		var numberOfTypeTriples;		this._loadStencilSets();		// get type of canvas.		var canvasTypeTriples = DataManager.query(			{type: ERDF.RESOURCE, value: ''},			{prefix: 'oryx', name: 'type'},			undefined);		if(canvasTypeTriples.length == 0)			ORYX.Log.warn("The loaded resource has no property of type 'oryx-type'.");		if(canvasTypeTriples.length > 1)			ORYX.Log.fatal("Oryx initialisation failed, because the loaded resource has too many properties of type 'oryx-type'.");				// get the stencil associated with the type		canvasStencil = ORYX.Core.StencilSet.stencil(			(numberOfTypeTriples == 1) ?				canvasTypeTriples[0].object.value :				this.getStencilSets().values()[0].findRootStencilName());					if (!canvasStencil) 			ORYX.Log.fatal("Oryx initialisation failed, because the stencil with the id %0 is not part of one of the loaded stencil sets.", canvasType[0].object);				// create the canvas		this._canvas = new ORYX.Core.Canvas({			width:  ORYX.CONFIG.CANVAS_WIDTH,			height: ORYX.CONFIG.CANVAS_HEIGHT,			'eventHandlerCallback': this.handleEvents.bind(this),			id:id		}, canvasStencil);						// create all dom		// TODO fix border, so the visible canvas has a double border and some spacing to the scrollbars		var div = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", null, ['div']);						div.appendChild(this._canvas.getRootNode());		div.appendChild(this._canvas.getHTMLContainer());		// set class for custom styling		div.addClassName("ORYX_Editor");			// get fullscreen option		var fullscreen = DataManager.query(			{type: ERDF.RESOURCE, value: '#'+this.id},			{prefix: 'oryx', name: 'mode'},			undefined).any(function(triple){				return triple.object.value === ORYX.CONFIG.MODE_FULLSCREEN;			});					//TODO make the height be read from eRDF data from the canvas.		// default, a non-fullscreen editor shall define its height by layout.setHeight(int) 		var layoutHeight = 400;						/* Ext 1.1 code. Replaced by Ext 2.0.		var parentContainer = fullscreen ? document.body : $(this.id);		this.layout = new Ext.BorderLayout(parentContainer, {					hideOnLayout: false,					center: {	                        	titlebar: false,	                        	autoScroll:true	                    	}					});		this.layout.beginUpdate();		this.layout.add('center', new Ext.ContentPanel(div, {title: 'Editor', closable: false}));		this.layout.endUpdate();*/		// stores DOM references to the specific regions of the layout		this.layout_regions = {			north: new Ext.Panel({ //TOOO make a composite of the oryx header and addable elements (for toolbar), second one should contain margins				region: 'north',				autoEl: 'div',				border: false			}),			east: new Ext.Panel({				region: 'east',				layout: 'fit',				/*layout: 'accordion',				layoutConfig: {	               // layout-specific configs go here					titleCollapse: true,					animate: true,					activeOnTop: true                },*/				autoEl: 'div',				collapsible: true,				split: true,				title: "East"			}),			south: new Ext.Panel({				region: 'south',				autoEl: 'div'			}),			west: new Ext.Panel({				region: 'west',				layout: 'fit',				autoEl: 'div',				collapsible: true,				split: true,				title: "West"			}),			center: new Ext.Panel({				region: 'center',				autoScroll: true,				items: {					layout: "fit",					autoHeight: true,					el: div				}			})		}				for (region in this.layout_regions) {			if (region != "center") {				this.layout_regions[region].hide();			}		}		 		var layout_config = {			layout: 'border',			items: [				this.layout_regions.north,				this.layout_regions.east,				this.layout_regions.south,				this.layout_regions.west,				this.layout_regions.center			]		}		// determine where to put the canvas and do so.		if (fullscreen) {			this.layout = new Ext.Viewport(layout_config)				} else {			layout_config.renderTo = this.id;			layout_config.height = layoutHeight;			this.layout = new Ext.Panel(layout_config)		}			 	// set the editor to the center, and refresh the size	 	div.parentNode.setAttributeNS(null, 'align', 'center');	 	div.setAttributeNS(null, 'align', 'left');		this._canvas.setSize({			width: ORYX.CONFIG.CANVAS_WIDTH,			height: ORYX.CONFIG.CANVAS_HEIGHT		});			// Register on Events		document.documentElement.addEventListener('keydown', this.catchKeyDownEvents.bind(this), true);		document.documentElement.addEventListener('keyup', this.catchKeyUpEvents.bind(this), true);		this.DOMEventListeners = $H({			'mousedown': [],			'mousemove': [],			'mouseup': [],			'mouseover': [],			'mouseout': [],			'mousedown': [],			'selectionchanged': []});		// get readonly option		var readonly = DataManager.query(			{type: ERDF.RESOURCE, value: '#'+this.id},			{prefix: 'oryx', name: 'mode'},			undefined).any(function(triple){				return triple.object.value === ORYX.CONFIG.MODE_READONLY;			});					// load plugins and stencil sets, if applicable		if(!readonly) window.setTimeout(this.loadPlugins.bind(this), 100);		// load content of this editor instance		window.setTimeout(this.loadContent.bind(this), 10);						// The Drop-Target from Yui-Ext		new Ext.dd.DropTarget(div.parentNode);				//new PeriodicalExecuter(this._canvas.update.bind(this._canvas), 1);				// if the editor is loaded to use the whole page, add a header.		if (fullscreen) {						// the oryx header			this.addToRegion("north", new Ext.Panel({				height: 30,				autoHeight: false,				border: false,				html: "<div id='oryx_editor_header'><a href=\"http://oryx-editor.org\" target=\"_blank\"><img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" /></a><div style='clear: both;'></div></div>" 			}))		}				// Close the loading Panel		window.setTimeout(function(){Ext.getCmp('oryx-loading-panel').hide()}, 500);						 	},		/**	 * adds a component to the specified region	 * 	 * @param {String} region	 * @param {Ext.Component} component	 * @param {String} title, optional	 * @return {Ext.Component} dom reference to the current region or null if specified region is unknown	 */	addToRegion: function(region, component, title) {				if (region.toLowerCase && this.layout_regions[region.toLowerCase()]) {			var current_region = this.layout_regions[region.toLowerCase()];			current_region.add(component);			/*if( (region.toLowerCase() == 'east' || region.toLowerCase() == 'west') && current_region.items.length == 2){ //!current_region.getLayout() instanceof Ext.layout.Accordion ){				var layout = new Ext.layout.Accordion( current_region.layoutConfig );            	current_region.setLayout( layout );								var items = current_region.items.clone();								current_region.items.each(function(item){ current_region.remove( item )})				items.each(function(item){ current_region.add( item )})							}	*/					ORYX.Log.debug("original dimensions of region %0: %1 x %2", current_region.region, current_region.width, current_region.height)			// update dimensions of region if required.			if  (!current_region.width && component.initialConfig && component.initialConfig.width) {				ORYX.Log.debug("resizing width of region %0: %1", current_region.region, component.initialConfig.width)					current_region.setWidth(component.initialConfig.width)			}			if  (component.initialConfig && component.initialConfig.height) {				ORYX.Log.debug("resizing height of region %0: %1", current_region.region, component.initialConfig.height)				var current_height = current_region.height || 0;				current_region.height = component.initialConfig.height + current_height;				current_region.setHeight(component.initialConfig.height + current_height)			}						// set title if provided as parameter.			if (typeof title == "string") {				current_region.setTitle(title);				}									// trigger doLayout() and show the pane			current_region.doLayout();			current_region.ownerCt.doLayout();			current_region.show();			if(Ext.isMac)				ORYX.Editor.resizeFix();						return current_region;		}				return null;	}, 	/**	 *  Laden der Plugins	 */	loadPlugins: function() {		// if there should be plugins but still are none, try again.		// TODO this should wait for every plugin respectively.		if (!ORYX.Plugins && ORYX.availablePlugins.length > 0) {			window.setTimeout(this.loadPlugins.bind(this), 100);			return;		}				var me = this;		var newPlugins = [];		var loadedStencilSetsNamespaces = this.getStencilSets().keys();		// Available Plugins will be initalize		ORYX.availablePlugins.each((function(value) {			ORYX.Log.debug("Initializing plugin '%0'", value.name);						if( (!value.requires 	|| !value.requires.namespaces 	|| value.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ) &&				(!value.notUsesIn 	|| !value.notUsesIn.namespaces 	|| !value.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ) ){				try {					var className = eval(value.name);					newPlugins.push(new className(this._getPluginFacade(), value));				} catch(e) {					ORYX.Log.warn("Plugin %0 is not available", value.name);				}										} else {				ORYX.Log.info("Plugin need a stencilset which is not loaded'", value.name);			}					}).bind(this));		newPlugins.each(function(value) {			// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data			if(value.registryChanged)				value.registryChanged(me.pluginsData);			// If there have an onSelection-Method it will pushed to the Editor Event-Handler			if(value.onSelectionChanged)				me.registerOnEvent('selectionchanged', value.onSelectionChanged.bind(value));		});		this.loadedPlugins = newPlugins;				// Hack for the Scrollbars		if(Ext.isMac) {//			window.setTimeout("window.resizeBy(0,0)", 10);			ORYX.Editor.resizeFix();		}				this.updateSelection();	},	_loadStencilSets: function() {				// for each stencilset url ...		DataManager.query(			{type: ERDF.RESOURCE, value: '#'+this.id},			{prefix: 'oryx', name: 'stencilset'},			undefined).each((					// ... load it.		function(triple) {						var url = triple.object.value;			//this.loadStencilSet(url);			ORYX.Core.StencilSet.loadStencilSet(url, this.id);		}).bind(this));				// load ss extensions		var url = ORYX.CONFIG.SS_EXTENSIONS_CONFIG;		//var url = "/oryx/build/stencilsets/extensions/extensions.json";				new Ajax.Request(url, {            method: 'GET',            asynchronous: false,			onSuccess: (function(transport) {								try {					eval("var jsonObject =" + transport.responseText);					//set reference to stencil set extensions definition					this.ss_extensions_def = jsonObject;										// for each stencilset extension ...					/*DataManager.query(						{type: ERDF.RESOURCE, value: '#'+this.id},						{prefix: 'oryx', name: 'ssextension'},						undefined).each((											// ... load it.					function(triple) {						this.loadSSExtension(triple.object.value);					/*	var namespace = triple.object.value;												var extension = jsonObject.extensions.find(function(ex) {							return (ex.namespace == namespace);						});												if(!extension) {							return;						}												var stencilset = stencilsets[extension["extends"]];												if(!stencilset) {							return;						}												stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension["definition"])						//stencilset.addExtension("/oryx/build/stencilsets/extensions/" + extension["definition"])						this.getRules().initializeRules(stencilset); 					}).bind(this));*/									} catch (e) {					ORYX.Log.error("Editor._loadStencilSets: Something went wrong when initialising stencil set extensions." + e);				}			}).bind(this),			onFailure: (function(transport) {				ORYX.Log.error("Editor._loadStencilSets: Loading stencil set extension configuration file failed." + transport);			}).bind(this)		});	},	/**	 * Responsible for loading the content into the editor. This method will	 * be called by the editor once at initialization time.	 */	loadContent: function() {				//parse erdfDOM but do not check ids!!!		var serialized = this.parseToSerializeObjects( $( this.id ).parentNode , true);					if (serialized) {			this.loadSerialized(serialized);			this.getCanvas().update();		}			},	/**	 * Returns a per-editor singleton plugin facade.	 * To be used in plugin initialization.	 */	_getPluginFacade: function() {		// if there is no pluginfacade already created:		if(!(this._pluginFacade))			// create it.			this._pluginFacade = {				offer:					this.offer.bind(this),				getStencilSets:			this.getStencilSets.bind(this),				getRules:				this.getRules.bind(this),				loadStencilSet:			this.loadStencilSet.bind(this),				createShape:			this.createShape.bind(this),				deleteShape:			this.deleteShape.bind(this),				getSelection:			this.getSelection.bind(this),				setSelection:			this.setSelection.bind(this),				updateSelection:		this.updateSelection.bind(this),				getCanvas:				this.getCanvas.bind(this),								importJSON:				this.importJSON.bind(this),				importERDF:				this.importERDF.bind(this),				getERDF:				this.getERDF.bind(this),								executeCommands:		this.executeCommands.bind(this),								registerOnEvent:		this.registerOnEvent.bind(this),				unregisterOnEvent:		this.unregisterOnEvent.bind(this),				registerEventType:		this.registerEventType.bind(this),				raiseEvent:				this.handleEvents.bind(this),				enableEvent:			this.enableEvent.bind(this),				disableEvent:			this.disableEvent.bind(this),								eventCoordinates:		this.eventCoordinates.bind(this),				getLayout:				this.getLayout.bind(this),				addToRegion:			this.addToRegion.bind(this)			};		// return it.		return this._pluginFacade;	},	/**	 * Implementes the command pattern	 * (The real usage of the command pattern	 * is implemented and shown in the Plugins/undo.js)	 *	 * @param <Oryx.Core.Command>[] Array of commands	 */	executeCommands: function(commands){				// Check if the argument is an array and the elements are from command-class		if ( 	commands instanceof Array 	&& 				commands.length > 0 		&& 				commands.all(function(command){ return command instanceof ORYX.Core.Command }) ) {					// Raise event for executing commands			this.handleEvents({				type		: 'executeCommands',				commands	: commands			});						// Execute every command			commands.each(function(command){				command.execute();			})					}	},			getERDF:function(){		// Get the serialized dom        var serializedDOM = DataManager.serializeDOM( this._getPluginFacade() );				// Add xml definition if there is no		if (!serializedDOM.startsWith("<?xml")) {			serializedDOM = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serializedDOM;		};				return serializedDOM;					}, 	/**	* Imports shapes in JSON with the following format:	* [	* 	id:<resourceId without hash>,	* 	type:<stencil id (stencil set namespace + id)>,	* 	serialize:<array of serialized shape properties>	* ]	*/	importJSON: function(jsonObject, noSelectionAfterImport) {				//renew resourceIds, but keep references		jsonObject.each(function(element) {			if(element.shape && element.shape instanceof ORYX.Core.Canvas)				return;							var id = element.id;						element.id = ORYX.Editor.provideId();						jsonObject.each(function(otherElement) {				otherElement.serialize.each(function(ser) {					if (ser.value == "#" + id) {						ser.value = "#" + element.id;					}				});			});		}.bind(this));				var commandClass = ORYX.Core.Command.extend({			construct: function(jsonObject, loadSerializedCB, noSelectionAfterImport, facade){				this.jsonObject = jsonObject;				this.noSelection = noSelectionAfterImport;				this.facade = facade;				this.shapes;				this.connections = [];				this.parents = new Hash();				this.selection = this.facade.getSelection();				this.loadSerialized = loadSerializedCB;			},						execute: function(){								if (!this.shapes) {					// Import the shapes out of the serialization							this.shapes	= this.loadSerialized( this.jsonObject );												//store all connections					this.shapes.each(function(shape) {						if (shape.getDockers) {							var dockers = shape.getDockers();							if (dockers) {								if (dockers.length > 0) {									this.connections.push([dockers.first(), dockers.first().getDockedShape(), dockers.first().referencePoint]);								}								if (dockers.length > 1) {									this.connections.push([dockers.last(), dockers.last().getDockedShape(), dockers.last().referencePoint]);								}							}						}												//store parents						this.parents[shape.id] = shape.parent;					}.bind(this));				} else {					this.shapes.each(function(shape) {						this.parents[shape.id].add(shape);					}.bind(this));										this.connections.each(function(con) {						con[0].setDockedShape(con[1]);						con[0].setReferencePoint(con[2]);						con[0].update();					});				}								this.parents.values().uniq().invoke("update");								if(!this.noSelection)					this.facade.setSelection(this.shapes);				else					this.facade.updateSelection();			},			rollback: function(){				var selection = this.facade.getSelection();								this.shapes.each(function(shape) {					selection = selection.without(shape);					this.facade.deleteShape(shape);				}.bind(this));								this.parents.values().uniq().each(function(parent) {					if(!this.shapes.member(parent))						parent.update();				}.bind(this));								this.facade.setSelection(selection);			}		})				var command = new commandClass(jsonObject, 										this.loadSerialized.bind(this),										noSelectionAfterImport,										this._getPluginFacade());				this.executeCommands([command]);					return command.shapes.clone();	},		/**	 * Import erdf structure to the editor	 *	 */	importERDF: function( erdfDOM ){		var serialized = this.parseToSerializeObjects( erdfDOM );					if(serialized)			return this.importJSON(serialized, true);	},	/**	 * Parses one process model to the serialized form	 * returns {type, id, serialize} for one specific object	 * 	 * @param {Object} oneProcessData	 */	parseToSerializeObjects: function( oneProcessData){				// Get a specific div from a given class name		var getElementsByClassNameFromDiv 	= function(doc, id){ return $A(doc.getElementsByTagName('div')).findAll(function(el){ return $A(el.attributes).any(function(attr){ return attr.nodeName == 'class' && attr.nodeValue == id }) })	}		// Get a specific div from a given class name				var getElementByIdFromDiv 			= function(doc, id){ return $A(doc.getElementsByTagName('div')).find(function(el){return el.getAttribute("id")== id}) }		// Get a specific div from a given class name				var getAsByHref						= function(doc, id){ return $A(doc.getElementsByTagName('a')).findAll(function(el){return el.getAttribute("href")== "#" + id}) }				// Get the oryx-editor div		var editorNode 	= getElementsByClassNameFromDiv( oneProcessData, '-oryx-canvas')[0];		// If no canvas node there --> return		if( !editorNode ){			ORYX.Log.warn("Import ERDF: No canvas node was found!")			return false		}		// Get all ids from the canvas node for rendering		var renderNodes = $A(editorNode.childNodes).collect(function(el){ return el.nodeName.toLowerCase() == "a" && el.getAttribute('rel') == 'oryx-render' ? el.getAttribute('href').slice(1) : null}).compact()						// Collect all nodes from the ids		renderNodes = renderNodes.collect(function(el){return getElementByIdFromDiv( oneProcessData, el)}.bind(this));						// Returns a new ID		var counter = 0;		var getNewId = ORYX.Editor.provideId;		/*var getNewId = function(){			var prefix = RESOURCE_ID_PREFIX;			while (this.getCanvas().getChildShapeByResourceId(prefix + "" + counter)) {counter++}			return prefix + "" + (counter++);		}.bind(this);*/						/*			// Reset every id with a unique id			renderNodes.each(function(node){				if (!node.getAttribute("id")) {					return				}				var id = node.getAttribute("id");				var newId = id;				if ($(id)) {					newId = getNewId();					var as = getAsByHref(oneProcessData, id);					as.each(function(a){						a.setAttribute("href", "#" + newId)					})				}								node.setAttribute("id", newId);							}.bind(this));		*/				// Add the canvas node to the render nodes		renderNodes.push(editorNode);			// Function for extract all eRDF-Attributes and give them back as an Object		var parseAttribute = function(node){		    			var res = {type: undefined, id: undefined ,serialize: [] }						// Set the resource id			if(node.getAttribute("id")){				res.id = node.getAttribute("id");			}			// If the node is the canvas simply			// set already the canvas as shape 			if(node.getAttribute("class") == "-oryx-canvas"){				res['shape'] = this.getCanvas();			}									// Set all attributes		    $A(node.childNodes).each( function(node){ 				if( node.nodeName.toLowerCase() == "span" && node.getAttribute('class')){		            var name 	= node.getAttribute('class').split("-");					var value 	= node.firstChild ? node.firstChild.nodeValue : '';										res.serialize.push({name: name[1], prefix:  name[0], value: value})					if( name[1] == "type" ){						res.type = value;					}				} else if( node.nodeName.toLowerCase() == "a" && node.getAttribute('rel')){		            var name 	= node.getAttribute('rel').split("-");					var value 	= node.getAttribute('href');										res.serialize.push({name: name[1], prefix:  name[0], value: value})		        }		    })					    return res.type ? res : null ;		}.bind(this)						// Collect all Attributes out of the Nodes		return renderNodes.collect(function(el){return parseAttribute(el)}.bind(this)).compact();					},		/**	 * Loads serialized objects to the oryx	 *	 */	loadSerialized: function( serialized ){				var canvas  = this.getCanvas();				// Bugfix (cf. http://code.google.com/p/oryx-editor/issues/detail?id=240)		// Deserialize the canvas' stencil set extensions properties first!		serialized.each(			function(pair){				if( pair.shape && pair.shape instanceof ORYX.Core.Canvas) {					pair.serialize.any(function(ser) {						if(ser.name == "ssextension" && ser.prefix == "oryx") {							this.loadSSExtension(ser.value);						}					}.bind(this));				}			}.bind(this)		);				serialized.each(function(ser){			// If the shape is the canvas, continue			if( ser.shape && ser.shape instanceof ORYX.Core.Canvas){				return;			}			// Try to create a new Shape			try {				// Create a new Stencil												var stencil = ORYX.Core.StencilSet.stencil( ser.type );					// Create a new Shape				var newShape = (stencil.type() == "node") ?									new ORYX.Core.Node(										{'eventHandlerCallback':this.handleEvents.bind(this)},										stencil) :									new ORYX.Core.Edge(										{'eventHandlerCallback':this.handleEvents.bind(this)},										stencil);								// Set the resource id				newShape.resourceId = ser.id;								// Add the shape to the canvas				canvas.add( newShape );												// Add to new shapes				ser['shape'] = newShape;							} catch(e) {				ORYX.Log.warn("LoadingContent: Stencil could not create.");				//return;			}							}.bind(this))								// Deserialize the properties from the shapes		serialized.each(			function(pair){				if( pair.shape )					pair.shape.deserialize(pair.serialize);			}.bind(this));		// Delete all resource ids if there are no nodes available		//DISABLED BECAUSE OF NEW RESOURCE ID HANDLING		/*serialized.each(function(pair){			if( pair.shape && !$(pair.shape.resourceId) ){				pair.shape.resourceId = null;			}		});	*/					// Update the canvas		//canvas.update();				// Check the size for the canvas		var maxWidth 	= 0;		var maxHeight 	= 0;		var offset 		= 100;		canvas.getChildShapes(true, function(shape){			var b = shape.bounds;			maxWidth 	= Math.max( maxWidth, b.lowerRight().x + offset)			maxHeight 	= Math.max( maxHeight, b.lowerRight().y + offset)		});					if( canvas.bounds.width() < maxWidth || canvas.bounds.height() < maxHeight ){			canvas.setSize({width: Math.max(canvas.bounds.width(), maxWidth), height: Math.max(canvas.bounds.height(), maxHeight)})		}				return serialized.reject(function(item) { return (item.shape instanceof ORYX.Core.Canvas)}).pluck("shape");					},		/**	* Loads a stencil set extension.	* The stencil set extensions definiton file must already	* be loaded when the editor is initialized.	*/	loadSSExtension: function(ss_extension_namespace) {								if (this.ss_extensions_def) {			var extension = this.ss_extensions_def.extensions.find(function(ex){				return (ex.namespace == ss_extension_namespace);			});						if (!extension) {				return;			}						var stencilset = this.getStencilSets()[extension["extends"]];						if (!stencilset) {				return;			}						stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension["definition"])			//stencilset.addExtension("/oryx/build/stencilsets/extensions/" + extension["definition"])			this.getRules().initializeRules(stencilset);						this._getPluginFacade().raiseEvent({				type: "stencilSetLoaded"			});		}			},		getLayout: function() {		return this.layout;	},	disableEvent: function(eventType){		if(this.DOMEventListeners.keys().member(eventType)) {			var value = this.DOMEventListeners.remove(eventType);			this.DOMEventListeners['disable_' + eventType] = value;		}	},	enableEvent: function(eventType){		if(this.DOMEventListeners.keys().member("disable_" + eventType)) {			var value = this.DOMEventListeners.remove("disable_" + eventType);			this.DOMEventListeners[eventType] = value;		}	},	registerEventType: function(eventType) {		if(!(this.DOMEventListeners.keys().member(eventType))) {			this.DOMEventListeners[eventType] = [];		}	},	/**	 *  Methods for the PluginFacade	 */	registerOnEvent: function(eventType, callback) {		if(!(this.DOMEventListeners.keys().member(eventType))) {			this.DOMEventListeners[eventType] = [];		}		this.DOMEventListeners[eventType].push(callback);	},	unregisterOnEvent: function(eventType, callback) {		if(this.DOMEventListeners.keys().member(eventType)) {			this.DOMEventListeners[eventType] = this.DOMEventListeners[eventType].without(callback);		} else {			// Event is not supported			// TODO: Error Handling		}	},	getSelection: function() {		return this.selection;	},	getStencilSets: function() { 		return ORYX.Core.StencilSet.stencilSets(this.id); 	},		getRules: function() {		return ORYX.Core.StencilSet.rules(this.id);	},		loadStencilSet: function(source) {		try {			ORYX.Core.StencilSet.loadStencilSet(source, this.id);			this.handleEvents({type:"stencilSetLoaded"});		} catch (e) {			ORYX.Log.warn("Requesting stencil set file failed. (" + e + ")");		}	},	offer: function(pluginData) {		if(!this.pluginsData.member(pluginData)){			this.pluginsData.push(pluginData);		}	},	setSelection: function(elements, subSelectionElement) {		if(!elements) {elements = []}		this.selection = elements;		this._subSelection = subSelectionElement;				this.handleEvents({type:'selectionchanged', elements:elements, subSelection: subSelectionElement})	},		updateSelection: function() {		var s = this.selection;		this.setSelection();		this.setSelection(s);	},	getCanvas: function() {		return this._canvas;	},		/**	*	option = {	*		type: string,	*		position: {x:int, y:int},	*		connectingType:	uiObj-Class	*		connectedShape: uiObj	*		draggin: bool	*		namespace: url	*       parent: ORYX.Core.AbstractShape	*		template: a template shape that the newly created inherits properties from.	*		}	*/	createShape: function(option) {		if(option && option.serialize && option.serialize instanceof Array){					var type = option.serialize.find(function(obj){return (obj.prefix+"-"+obj.name) == "oryx-type"});			var stencil = ORYX.Core.StencilSet.stencil(type.value);					if(stencil.type() == 'node'){				var newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);				} else {				var newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);				}					this.getCanvas().add(newShapeObject);			newShapeObject.deserialize(option.serialize);					return newShapeObject;		}		// If there is no argument, throw an exception		if(!option || !option.type || !option.namespace) { throw "To create a new shape you have to give an argument with type and namespace";}				var canvas = this.getCanvas();		var newShapeObject;		// Get the shape type		var shapetype = option.type;		// Get the stencil set		var sset = ORYX.Core.StencilSet.stencilSet(option.namespace);		// Create an New Shape, dependents on an Edge or a Node		if(sset.stencil(shapetype).type() == "node") {			newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))		} else {			newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))		}				// when there is a template, inherit the properties.		if(option.template) {			newShapeObject._jsonStencil.properties = option.template._jsonStencil.properties;			newShapeObject.postProcessProperties();		}		// Add to the canvas		if(option.parent && newShapeObject instanceof ORYX.Core.Node) {			option.parent.add(newShapeObject);		} else {			canvas.add(newShapeObject);		}						// Set the position		var point = option.position ? option.position : {x:100, y:200};					var con;		// If there is create a shape and in the argument there is given an ConnectingType and is instance of an edge		if(option.connectingType && option.connectedShape && !(newShapeObject instanceof ORYX.Core.Edge)) {			// there will be create a new Edge			con = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(option.connectingType));						// And both endings dockers will be referenced to the both shapes			con.dockers.first().setDockedShape(option.connectedShape);						var magnet = option.connectedShape.getDefaultMagnet()			var cPoint = magnet ? magnet.bounds.center() : option.connectedShape.bounds.midPoint();			con.dockers.first().setReferencePoint( cPoint );			con.dockers.last().setDockedShape(newShapeObject);			con.dockers.last().setReferencePoint(newShapeObject.getDefaultMagnet().bounds.center());								// The Edge will be added to the canvas and be updated			canvas.add(con);				con.update();					} 				// Move the new Shape to the position		if(newShapeObject instanceof ORYX.Core.Edge && option.connectedShape) {			newShapeObject.dockers.first().setDockedShape(option.connectedShape);						if( option.connectedShape instanceof ORYX.Core.Node ){				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.getDefaultMagnet().bounds.center());									newShapeObject.dockers.last().bounds.centerMoveTo(point);						} else {				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.bounds.midPoint());											}		} else {						var b = newShapeObject.bounds			b.centerMoveTo(point);						var upL = b.upperLeft();			b.moveBy( -Math.min(upL.x, 0) , -Math.min(upL.y, 0) )						var lwR = b.lowerRight();			b.moveBy( -Math.max(lwR.x-canvas.bounds.width(), 0) , -Math.max(lwR.y-canvas.bounds.height(), 0) )					}				// Update the shape		newShapeObject._update(false);				// And refresh the selection		if(!(newShapeObject instanceof ORYX.Core.Edge)) {			this.setSelection([newShapeObject]);		}				if(con && con.alignDockers) {			con.alignDockers();		} 		if(newShapeObject.alignDockers) {			newShapeObject.alignDockers();		}		return newShapeObject;	},		deleteShape: function(shape) {		//remove shape from parent		// this also removes it from DOM		shape.parent.remove(shape);				//delete references to outgoing edges		shape.getOutgoingShapes().each(function(os) {			var docker = os.getDockers().first();			if(docker && docker.getDockedShape() == shape) {				docker.setDockedShape(undefined);			}		});				//delete references to incoming edges		shape.getIncomingShapes().each(function(is) {			var docker = is.getDockers().last();			if(docker && docker.getDockedShape() == shape) {				docker.setDockedShape(undefined);			}		});				//delete references of the shape's dockers		shape.getDockers().each(function(docker) {			docker.setDockedShape(undefined);		});	},	/** **************************************	*	Event-Handler Methods	*	*/	_executeEvents: function() {				this._queueRunning = true;		while(this._eventsQueue.length > 0) {						var val = this._eventsQueue.shift();						//window.setTimeout(function(){				if(this.DOMEventListeners.keys().member(val.event.type)) {					this.DOMEventListeners[val.event.type].each((function(value) {						value(val.event, val.arg);								}).bind(this));				}			//}.bind(this), 10)					}		this._queueRunning = false;	},		/**	 * Leitet die Events an die Editor-Spezifischen Event-Methoden weiter	 * @param {Object} event Event , welches gefeuert wurde	 * @param {Object} uiObj Target-UiObj	 */	handleEvents: function(event, uiObj) {		ORYX.Log.trace("Dispatching event type %0 on %1", event.type, uiObj);		switch(event.type) {			case 'mousedown':				this._handleMouseDown(event, uiObj);				break;			case 'mousemove':				this._handleMouseMove(event, uiObj);				break;			case 'mouseup':				this._handleMouseUp(event, uiObj);				break;			case 'mouseover':				this._handleMouseHover(event, uiObj);				break;			case 'mouseout':				this._handleMouseOut(event, uiObj);				break;		}		this._eventsQueue.push({event: event, arg: uiObj});		if(!this._queueRunning) {			this._executeEvents();		}				// TODO: Make this return whether no listener returned false.		// So that, when one considers bubbling undesireable, it won't happen.		return false;	},	catchKeyUpEvents: function() {		this.__currentKey = null;	},		catchKeyDownEvents: function(event) {				// assure we have the current event.        if (!event)             event = window.event;                // get the currently pressed key code.        var pressedKey = event.which || event.keyCode;				// This is a mac-specific fix. The mozilla event object has no knowledge		// of meta key modifier on osx, however, it is needed for certain		// shortcuts. This fix adds the metaKey field to the event object, so		// that all listeners that registered per Oryx plugin facade profit from		// this. The original bug is filed in		// https://bugzilla.mozilla.org/show_bug.cgi?id=418334		if (this.__currentKey == ORYX.CONFIG.KEY_CODE_META) {			event.appleMetaKey = true;		}		this.__currentKey = pressedKey;				ORYX.Log.debug("Key %0 was pressed. metaKey is %1", pressedKey, event.appleMetaKey);				// forward to dispatching.		this.handleEvents.apply(this, arguments);	},	_handleMouseDown: function(event, uiObj) {				// get canvas.		var canvas = this.getCanvas();		// find the shape that is responsible for this element's id.		var element = event.currentTarget;		var elementController = uiObj;		// gather information on selection.		var currentIsSelectable = (elementController !== null) &&			(elementController !== undefined) && (elementController.isSelectable);		var currentIsMovable = (elementController !== null) &&			(elementController !== undefined) && (elementController.isMovable);		var modifierKeyPressed = event.shiftKey || event.ctrlKey;		var noObjectsSelected = this.selection.length === 0;		var currentIsSelected = this.selection.member(elementController);		// Rule #1: When there is nothing selected, select the clicked object.		if(currentIsSelectable && noObjectsSelected) {			this.setSelection([elementController]);			ORYX.Log.trace("Rule #1 applied for mouse down on %0", element.id);		// Rule #3: When at least one element is selected, and there is no		// control key pressed, and the clicked object is not selected, select		// the clicked object.		} else if(currentIsSelectable && !noObjectsSelected &&			!modifierKeyPressed && !currentIsSelected) {			this.setSelection([elementController]);			//var objectType = elementController.readAttributes();			//alert(objectType[0] + ": " + objectType[1]);			ORYX.Log.trace("Rule #3 applied for mouse down on %0", element.id);		// Rule #4: When the control key is pressed, and the current object is		// not selected, add it to the selection.		} else if(currentIsSelectable && modifierKeyPressed			&& !currentIsSelected) {							var newSelection = this.selection.clone();			newSelection.push(elementController)			this.setSelection(newSelection)			ORYX.Log.trace("Rule #4 applied for mouse down on %0", element.id);		// Rule #6		} else if(currentIsSelectable && currentIsSelected &&			modifierKeyPressed) {			var newSelection = this.selection.clone();			this.setSelection(newSelection.without(elementController))			ORYX.Log.trace("Rule #6 applied for mouse down on %0", elementController.id);		// Rule #5: When there is at least one object selected and no control		// key pressed, we're dragging.		/*} else if(currentIsSelectable && !noObjectsSelected			&& !modifierKeyPressed) {			if(this.log.isTraceEnabled())				this.log.trace("Rule #5 applied for mouse down on "+element.id);*/		// Rule #2: When clicked on something that is neither		// selectable nor movable, clear the selection, and return.		} else if (!currentIsSelectable && !currentIsMovable) {						this.setSelection([]);						ORYX.Log.trace("Rule #2 applied for mouse down on %0", element.id);			return;		// Rule #7: When the current object is not selectable but movable,		// it is probably a control. Leave the selection unchanged but set		// the movedObject to the current one and enable Drag. Dockers will		// be processed in the dragDocker plugin.		} else if(!currentIsSelectable && currentIsMovable && !(elementController instanceof ORYX.Core.Controls.Docker)) {						// TODO: If there is any moveable elements, do this in a plugin			//ORYX.Core.UIEnableDrag(event, elementController);			ORYX.Log.trace("Rule #7 applied for mouse down on %0", element.id);				// Rule #8: When the element is selectable and is currently selected and no 		// modifier key is pressed		} else if(currentIsSelectable && currentIsSelected &&			!modifierKeyPressed) {						this._subSelection = this._subSelection != elementController ? elementController : undefined;									this.setSelection(this.selection, this._subSelection);						ORYX.Log.trace("Rule #8 applied for mouse down on %0", element.id);		}						// prevent event from bubbling, return.		Event.stop(event);		return;	},	_handleMouseMove: function(event, uiObj) {		return;	},	_handleMouseUp: function(event, uiObj) {		// get canvas.		var canvas = this.getCanvas();		// find the shape that is responsible for this elemement's id.		var elementController = uiObj;		//get event position		var evPos = this.eventCoordinates(event);		//Event.stop(event);	},	_handleMouseHover: function(event, uiObj) {		return;	},	_handleMouseOut: function(event, uiObj) {		return;	},	/**	 * Calculates the event coordinates to SVG document coordinates.	 * @param {Event} event	 * @return {SVGPoint} The event coordinates in the SVG document	 */	eventCoordinates: function(event) {		var canvas = this.getCanvas();		var svgPoint = canvas.node.ownerSVGElement.createSVGPoint();		svgPoint.x = event.clientX;		svgPoint.y = event.clientY;		var matrix = canvas.node.getScreenCTM();		return svgPoint.matrixTransform(matrix.inverse());	}};ORYX.Editor = Clazz.extend(ORYX.Editor);// TODO Implement namespace awareness on attribute level./** * graft() function * Originally by Sean M. Burke from interglacial.com, altered for usage with * SVG and namespace (xmlns) support. Be sure you understand xmlns before * using this funtion, as it creates all grafted elements in the xmlns * provided by you and all element's attribures in default xmlns. If you * need to graft elements in a certain xmlns and wish to assign attributes * in both that and another xmlns, you will need to do stepwise grafting, * adding non-default attributes yourself or you'll have to enhance this * function. Latter, I would appreciate: martin�apfelfabrik.de * @param {Object} namespace The namespace in which * 					elements should be grafted. * @param {Object} parent The element that should contain the grafted * 					structure after the function returned. * @param {Object} t the crafting structure. * @param {Object} doc the document in which grafting is performed. */ORYX.Editor.graft = function(namespace, parent, t, doc) {    doc = (doc || (parent && parent.ownerDocument) || document);    var e;    if(t === undefined) {        throw "Can't graft an undefined value";    } else if(t.constructor == String) {        e = doc.createTextNode( t );    } else {        for(var i = 0; i < t.length; i++) {            if( i === 0 && t[i].constructor == String ) {                var snared;                snared = t[i].match( /^([a-z][a-z0-9]*)\.([^\s\.]+)$/i );                if( snared ) {                    e = doc.createElementNS(namespace, snared[1] );                    e.setAttributeNS(null, 'class', snared[2] );                    continue;                }                snared = t[i].match( /^([a-z][a-z0-9]*)$/i );                if( snared ) {                    e = doc.createElementNS(namespace, snared[1] );  // but no class                    continue;                }                // Otherwise:                e = doc.createElementNS(namespace, "span" );                e.setAttribute(null, "class", "namelessFromLOL" );            }            if( t[i] === undefined ) {                throw "Can't graft an undefined value in a list!";            } else if( t[i].constructor == String || t[i].constructor == Array ) {                this.graft(namespace, e, t[i], doc );            } else if(  t[i].constructor == Number ) {                this.graft(namespace, e, t[i].toString(), doc );            } else if(  t[i].constructor == Object ) {                // hash's properties => element's attributes                for(var k in t[i]) { e.setAttributeNS(null, k, t[i][k] ); }            } else {			}        }    }	if(parent) {	    parent.appendChild( e );	} else {	}    return e; // return the topmost created node};ORYX.Editor.provideId = function() {	var res = [], hex = '0123456789ABCDEF';	for (var i = 0; i < 36; i++) res[i] = Math.floor(Math.random()*0x10);	res[14] = 4;	res[19] = (res[19] & 0x3) | 0x8;	for (var i = 0; i < 36; i++) res[i] = hex[res[i]];	res[8] = res[13] = res[18] = res[23] = '-';	return "oryx_" + res.join('');};/** * When working with Ext, conditionally the window needs to be resized. To do * so, use this class method. Resize is deferred until 100ms, and all subsequent * resizeBugFix calls are ignored until the initially requested resize is * performed. */ORYX.Editor.resizeFix = function() {	if (!ORYX.Editor._resizeFixTimeout) {		ORYX.Editor._resizeFixTimeout = window.setTimeout(function() {			window.resizeBy(1,1);			window.resizeBy(-1,-1);			ORYX.Editor._resizefixTimeout = null;		}, 100); 	}};/** * Workaround for SAFARI/Webkit, because * when trying to check SVGSVGElement of instanceof there is  * raising an error *  */ORYX.Editor.SVGClassElementsAreAvailable = true;ORYX.Editor.setMissingClasses = function() {		try {		SVGElement;	} catch(e) {		ORYX.Editor.SVGClassElementsAreAvailable = false;		SVGSVGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'svg').toString();		SVGGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'g').toString();		SVGPathElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'path').toString();		SVGTextElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'text').toString();		//SVGMarkerElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'marker').toString();		SVGRectElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'rect').toString();		SVGImageElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'image').toString();		SVGCircleElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'circle').toString();		SVGEllipseElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'ellipse').toString();		SVGLineElement	 	= document.createElementNS('http://www.w3.org/2000/svg', 'line').toString();		SVGPolylineElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polyline').toString();		SVGPolygonElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polygon').toString();			}	}ORYX.Editor.checkClassType = function( classInst, classType ) {		if( ORYX.Editor.SVGClassElementsAreAvailable ){		return classInst instanceof classType	} else {		return classInst == classType	}};