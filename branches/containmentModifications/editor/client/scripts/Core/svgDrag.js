/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}new function(){	ORYX.Core.UIEnableDrag = function(event, uiObj, option){			this.uiObj = uiObj;		var upL = uiObj.bounds.upperLeft();				var a = uiObj.node.getScreenCTM();		this.faktorXY = {			x: a.a,			y: a.d		};				this.scrollNode = uiObj.node.ownerSVGElement.parentNode.parentNode;				this.offSetPosition = {			x: Event.pointerX(event) - (upL.x * this.faktorXY.x),			y: Event.pointerY(event) - (upL.y * this.faktorXY.y)		};				this.offsetScroll = {			x: this.scrollNode.scrollLeft,			y: this.scrollNode.scrollTop		};				this.dragCallback = ORYX.Core.UIDragCallback.bind(this);		this.disableCallback = ORYX.Core.UIDisableDrag.bind(this);				this.movedCallback = option ? option.movedCallback : undefined;		this.upCallback = option ? option.upCallback : undefined;				document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);			};		ORYX.Core.UIDragCallback = function(event){			var position = {			x: Event.pointerX(event) - this.offSetPosition.x,			y: Event.pointerY(event) - this.offSetPosition.y		}				position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft;		position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;				position.x /= this.faktorXY.x;		position.y /= this.faktorXY.y;				this.uiObj.bounds.moveTo(position);		//this.uiObj.update();				if (this.movedCallback) 			this.movedCallback(event);				Event.stop(event);			};		ORYX.Core.UIDisableDrag = function(event){		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);				if (this.upCallback) 			this.upCallback(event);				this.upCallback = undefined;		this.movedCallback = undefined;				Event.stop(event);	};	}();new function(){		/**	 * Implementation of a special drag handler	 * 	 * @class	 */	ORYX.Core.DragZone = function(el, facade){		this.facade = facade;	    ORYX.Core.DragZone.superclass.constructor.call(this, el, {shadow: !Ext.isMac});				// Init snap to grid		this.snap = new ORYX.Core.SnapToGrid();		// Init selected rect		this.rectangle = new ORYX.Core.SelectedRect(this.facade.getCanvas().getSvgContainer(), {"stroke-opacity":0.5});				// Show grid line if enabled		if (ORYX.CONFIG.SHOW_GRIDLINE) {			this.vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);			this.hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);		}			};	Ext.extend(ORYX.Core.DragZone, Ext.dd.DragZone, {		afterDragDrop: function(){ 	/* Can be overwritten */},		afterDragOver: function(){ 	/* Can be overwritten */},		afterDragEnter: function(){ /* Can be overwritten */},				onInitDrag: function(){			this.bounds = this.getBounds() || false;						if (this.bounds){				// Set snap parameters				this.snap.setScale(this.getScale());				this.snap.setReferenceBounds(this.bounds);							this.snap.setReferenceShapes();								// Get shape to consider for snapping				if (this.snapTimer)					window.clearTimeout(this.snapTimer)								this.snapTimer = window.setTimeout(function(){					this.snap.setReferenceShapes(this.getSnapReferencedShapes());				}.bind(this), 1);								}						return ORYX.Core.DragZone.superclass.onInitDrag.apply(this, arguments);		},				onDrag: function(evt){			if (!this.rectangle||!this.bounds||this.rectangle.hidden){ 				return;			}						 var position = this.getNormalizedXY(evt);			 position = this.snapPosition(position);			 this.bounds.moveTo(position);			 this.rectangle.resize(this.bounds);		},				hide: function(){					 	this.rectangle.hide();						if (this.vLine)				this.vLine.hide();			if (this.hLine)				this.hLine.hide();		},				show: function(){		 	this.rectangle.show();		},				beforeDragDrop: function(){			if (!this.rectangle){				return;			}			this.hide();			this.snap.setReferenceShapes();		},				beforeDragEnter: function(){			if (!this.rectangle||!this.bounds){				return;			}		 	this.show()		},				beforeDragOut: function(){			if (!this.rectangle||!this.bounds){				return;			}		 	this.hide();		},				// private (@overwrite)	    onDragDrop : function(e, id){	        var target = this.cachedTarget || Ext.dd.DragDropMgr.getDDById(id);			this.cachedTarget = false;			this.proxy.hide();				        if(this.beforeDragDrop(target, e, id) !== false){	            if(target.isNotifyTarget){	                if(target.notifyDrop(this, e, this.dragData)){ // valid drop?	                    this.onValidDrop(target, e, id);	                }else{	                    this.onInvalidDrop(target, e, id);	                }	            }else{	                this.onValidDrop(target, e, id);	            }	            	            if(this.afterDragDrop){					window.setTimeout(function(){	               		this.afterDragDrop.apply(this, arguments);					}.bind(this, target, e, id), 1)	            }	        }	        delete this.cachedTarget;	    },				// private (@overwrite)		afterRepair: function(){			this.dragging = false;		},					/**		 *		 * @return {Array} Shapes which should be considered for snapping		 */	 		getSnapReferencedShapes: function(){							return this.facade.getCanvas().getChildShapes(true);					},				/**		 *		 * @return {Object} Returns a x/y coordinate normalized to the canvas		 */		getNormalizedXY: function(evt){						var xy = evt.getXY();			var pos = {x: xy[0], y: xy[1]};				var a = this.facade.getCanvas().node.getScreenCTM();						// Correcting the UpperLeft-Offset			pos.x -= a.e; pos.y -= a.f;			// Correcting the Zoom-Faktor			pos.x /= a.a; pos.y /= a.d;									var mid = this.bounds ? this.bounds.midPoint() : {x:0, y:0};						// Set that the position is not lower than zero			pos.x = Math.max( mid.x , pos.x )			pos.y = Math.max( mid.y , pos.y )				// Set that the position is not bigger than the canvas			var c = this.facade.getCanvas();			pos.x = Math.min( c.bounds.width() - mid.x, 	pos.x)			pos.y = Math.min( c.bounds.height() - mid.y, 	pos.y)										return pos;		},				snapPosition: function(pos){						// Adjust by midpoint			var mid = this.bounds.midPoint();			pos.x -= mid.x; pos.y -= mid.y;						var hor, ver;			var onHor = function(x){hor = x}.bind(this);			var onVer = function(y){ver = y}.bind(this);			pos = this.snap.adjustPoint(pos, onHor, onVer);						if (this.hLine&&this.vLine){				if (hor === undefined){ this.hLine.hide() } else { this.hLine.update(hor) }				if (ver === undefined){ this.vLine.hide() } else { this.vLine.update(ver) }			}						return pos;		},				/**		 * Return the scale factor of the canvas		 * @return {int}		 */ 		getScale: function(){			try {				return this.facade.getCanvas().node.transform.baseVal.getItem(0).matrix.a;			} catch(e) {				return 1;			}		},			/**		 * Return the bounds of a new shape		 * @return {ORYX.Core.Bounds}		 */		getBounds: function(){			var option = Ext.dd.Registry.getHandle(this.DDM.currentTarget);			var stencil = this.facade.getStencilSets()[option.namespace].stencil(option.type);						if (stencil.type() != "node"){				return;			}						return new ORYX.Core.Node({}, stencil).bounds.clone();		}	});				/**	 * Implementation of some helper methods	 * for snap to grid. Mainly to adjust a point	 * to the currently related shapes.	 * @class ORYX.Core.SnapToGrid	 * 	 */	ORYX.Core.SnapToGrid = Clazz.extend({			construct: function(){			this.points = [];			this.scale = 1;			this.bounds = undefined;					},				setReferenceShapes: function(shapes){						if (this.timer)				window.clearTimeout(this.timer);							this.points = [];						if (!(shapes instanceof Array) || shapes.length == 0){				return;			}						this.timer = window.setTimeout(function(){								// For all these shapes				shapes.each((function(value) {					if(!(value instanceof ORYX.Core.Edge)) {						var ul 		= value.absoluteXY();						var width 	= value.bounds.width();						var height 	= value.bounds.height();						// Add the upperLeft, center and lowerRight - Point to the distancePoints						this.points.push({							ul: {								x: ul.x,								y: ul.y							},							c: {								x: ul.x + (width / 2),								y: ul.y + (height / 2)							},							lr: {								x: ul.x + width,								y: ul.y + height							}						});					}				}).bind(this));							}.bind(this), 1);		},				setReferenceBounds: function(bounds){			this.bounds = bounds || undefined;		},			setScale: function(scale){			this.scale = scale || 1;		},					adjustPoint: function(point, adjustedHorizontalClb, adjustedVerticalClb){						// Get the current Bounds			var bounds = this.bounds;			if (!bounds){				return;			}						var ulThres = 6;			var cThres 	= 16;			var lrThres = 6;				var scale = this.scale;						var ul 	= { x: (point.x/scale), y: (point.y/scale)};			var c 	= { x: (point.x/scale) + (bounds.width()/2), y: (point.y/scale) + (bounds.height()/2)};			var lr 	= { x: (point.x/scale) + (bounds.width()), y: (point.y/scale) + (bounds.height())};				var offsetX, offsetY;			var gridX, gridY;						// For each distant point			this.points.each(function(value) {					var x, y, gx, gy;				if (Math.abs(value.c.x-c.x) < cThres){					x = value.c.x-c.x;					gx = value.c.x;				}/* else if (Math.abs(value.ul.x-ul.x) < ulThres){					x = value.ul.x-ul.x;					gx = value.ul.x;				} else if (Math.abs(value.lr.x-lr.x) < lrThres){					x = value.lr.x-lr.x;					gx = value.lr.x;				} */									if (Math.abs(value.c.y-c.y) < cThres){					y = value.c.y-c.y;					gy = value.c.y;				}/* else if (Math.abs(value.ul.y-ul.y) < ulThres){					y = value.ul.y-ul.y;					gy = value.ul.y;				} else if (Math.abs(value.lr.y-lr.y) < lrThres){					y = value.lr.y-lr.y;					gy = value.lr.y;				} */					if (x !== undefined) {					offsetX = offsetX === undefined ? x : (Math.abs(x) < Math.abs(offsetX) ? x : offsetX);					if (offsetX === x)						gridX = gx;				}					if (y !== undefined) {					offsetY = offsetY === undefined ? y : (Math.abs(y) < Math.abs(offsetY) ? y : offsetY);					if (offsetY === y)						gridY = gy;				}			});									if (offsetX !== undefined) {				ul.x += offsetX;					ul.x *= scale;				if (gridX!==undefined&&adjustedVerticalClb instanceof Function)					adjustedVerticalClb(gridX);			} else {				ul.x = (point.x - (point.x % (ORYX.CONFIG.GRID_DISTANCE/2)));			}						if (offsetY !== undefined) {					ul.y += offsetY;				ul.y *= scale;				if (this.hLine&&gridY)					this.hLine.update(gridY);				if (gridY!==undefined&&adjustedHorizontalClb instanceof Function)					adjustedHorizontalClb(gridY);			} else {				ul.y = (point.y - (point.y % (ORYX.CONFIG.GRID_DISTANCE/2)));			}						return ul;		}			});		/**	 * Implementation of a selection rectangle	 * Mainly to show current selection or drag area	 * @class	 * 	 */ 	ORYX.Core.SelectedRect = Clazz.extend({			construct: function(parentId, options) {				this.parentId = parentId;				this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", $(parentId),						['g']);				this.dashedArea = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,				['rect', Ext.apply({x: 0, y: 0,					'stroke-width': 1, stroke: '#777777', fill: 'none',					'stroke-dasharray': '2,2',					'pointer-events': 'none'}, options ||{})]);				this.hide();			},			hide: function() {			this.node.setAttributeNS(null, 'display', 'none');			this.hidden = true;		},			show: function() {			this.node.setAttributeNS(null, 'display', '');			this.hidden = false;		},			resize: function(bounds) {			var upL = bounds.upperLeft();				var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;				this.dashedArea.setAttributeNS(null, 'width', bounds.width() + 2*padding);			this.dashedArea.setAttributeNS(null, 'height', bounds.height() + 2*padding);			this.node.setAttributeNS(null, 'transform', "translate("+ (upL.x - padding) +", "+ (upL.y - padding) +")");		}			});				/**	 * Implementation of gridlines	 * Horizontal or vertical are available	 * 	 * @class ORYX.Plugins.GridLine	 * 	 */	ORYX.Core.GridLine = Clazz.extend({				construct: function(parentId, direction) {				if (ORYX.Core.GridLine.DIR_HORIZONTAL !== direction && ORYX.Core.GridLine.DIR_VERTICAL !== direction) {				direction = ORYX.Plugins.GridLine.DIR_HORIZONTAL			}								this.parent = $(parentId);			this.direction = direction;			this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent,						['g']);				this.line = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,				['path', {d: "",					'stroke-width': 1, stroke: 'silver', fill: 'none',					'stroke-dasharray': '5,5',					'pointer-events': 'none'}]);				this.hide();			},			hide: function() {			this.node.setAttributeNS(null, 'display', 'none');		},			show: function() {			this.node.setAttributeNS(null, 'display', '');		},			getScale: function(){			try {				return this.parent.parentNode.transform.baseVal.getItem(0).matrix.a;			} catch(e) {				return 1;			}		},				update: function(pos) {						if (this.direction === ORYX.Core.GridLine.DIR_HORIZONTAL) {				var y = pos instanceof Object ? pos.y : pos; 				var cWidth = this.parent.parentNode.parentNode.width.baseVal.value/this.getScale();				this.line.setAttributeNS(null, 'd', 'M 0 '+y+ ' L '+cWidth+' '+y);			} else {				var x = pos instanceof Object ? pos.x : pos; 				var cHeight = this.parent.parentNode.parentNode.height.baseVal.value/this.getScale();				this.line.setAttributeNS(null, 'd', 'M'+x+ ' 0 L '+x+' '+cHeight);			}						this.show();		}			});		/**	 * Some statics	 */	ORYX.Core.GridLine.DIR_HORIZONTAL = "hor";	ORYX.Core.GridLine.DIR_VERTICAL = "ver";			/**	 * Implementation of a command which	 * add all children from the same parent to it.	 * 	 * @param {facade} facade	 * @param {ORYX.Core.Shape} shape	 * @param {boolean} alsoRemove Indicated if also the childs have to be removed from the shape which are outside or not	 */	ORYX.Core.EnsureChildCommand = ORYX.Core.Command.extend({					construct: function(facade, shapes, alsoRemove){				this.shapes 	= shapes instanceof Array ? shapes : [shapes];				this.facade 	= facade;				this.alsoRemove = alsoRemove === true;				this.changes;			},						execute: function(){								if (!ORYX.CONFIG.CONTAIN_AUTOMATICALY){ return; }								if (this.changes){					this.exectueAgain();					return;				}								// Get all children (all elements from the canvas and all children of the shapes parent)				var children = [].concat(this.facade.getCanvas().getChildNodes());				this.shapes.each(function(shape){					if (!(shape.parent instanceof ORYX.Core.Canvas)){						children = children.concat(shape.parent.getChildNodes());					}				});				children = children.uniq();												var shapes = [];				this.shapes.each(function(shape){					// Get the most top element 					// which is not the canvas					var mostTopShape = shape;					while(mostTopShape&&!(mostTopShape.parent instanceof ORYX.Core.Canvas)){						mostTopShape = mostTopShape.parent;					}										// The shapes which might be one of the parent					// could be all shapes from the most top, or the shape themselves					if (mostTopShape&&!shapes.include(mostTopShape)){						var ch = mostTopShape.getChildNodes(true).reverse();						ch = ch.findAll(function(child){							return this.facade.getRules().isContainer(child)						}.bind(this))						shapes = shapes.concat(shape, mostTopShape, ch);					}				}.bind(this));				shapes = shapes.uniq();												// Cache the absolute bounds 				var sBounds = {}								this.changes = $H({});								// For every considered shape				children.each(function(child){										// Get position					var ul = child.absoluteXY();					var lr = {x:ul.x+child.bounds.width(), y:ul.y+child.bounds.height()};										// Iterate over all possible parent shapes								shapes.any(function(parent){						// Check if parent is child						if (child === parent){ return false; }												// Cache the absolute bounds						if (!sBounds[parent.getId()]){							sBounds[parent.getId()] = parent.absoluteBounds();						}						var bounds = sBounds[parent.getId()];												// Check if the child is within the parent						if (bounds.isIncluded(ul, -2) && bounds.isIncluded(lr, -2)){														// Check if the child can be contained in the parent							if (this.facade.getRules().canContain({containingShape:parent,containedShape:child})){								this.add(parent, child, bounds);								return true;							}						}						return false;					}.bind(this));				}.bind(this));								/**				 * If also removing is wished				 */				if (this.alsoRemove){					shapes.each(function(shape){						// Cache the absolute bounds						if (!sBounds[shape.getId()]){							sBounds[shape.getId()] = shape.absoluteBounds();						}						var bounds = sBounds[shape.getId()];						var childs = shape.getChildNodes();												childs.each(function(child){							var ul = child.absoluteXY();							var lr = {x:ul.x+child.bounds.width(), y:ul.y+child.bounds.height()};							if (!bounds.isIncluded(ul, 2)&&!bounds.isIncluded(lr, 2)){								var parent = this.getContainerParent(shape.parent, child);								if (parent){									this.add(parent, child, sBounds[parent.getId()] || parent.absoluteBounds());								}							}						}.bind(this))					}.bind(this))				}								this.facade.getCanvas().update();			},						add: function(parent, child, bounds){				// If all TRUE, adds it				var cUl = child.absoluteXY();				var pUl = bounds.upperLeft();				var pos = {x:cUl.x-pUl.x, y:cUl.y-pUl.y}				// Cache changes for rollback				this.changes[child.getId()] = {											shape: child,											oldParent: child.parent,											newParent: parent,											oldPosition: child.bounds.upperLeft(),											newPosition: pos										}								parent.add(child);				child.bounds.moveTo(pos);					},						getContainerParent: function(parent, shape){				while(parent && !this.facade.getRules().canContain({containingShape:parent,containedShape:shape})){					parent = parent.parent;				}				return parent;			},						exectueAgain: function(){				// Iterate over all changes and rollback				this.changes.each(function(pair){					var parent = pair.value.newParent;					var shape = pair.value.shape;					parent.add(shape);					shape.bounds.moveTo(pair.value.newPosition);				}.bind(this))				this.facade.getCanvas().update();			},						rollback: function(){								if (!ORYX.CONFIG.CONTAIN_AUTOMATICALY){ return; }								// Iterate over all changes and rollback				this.changes.each(function(pair){					var parent = pair.value.oldParent;					var shape = pair.value.shape;					parent.add(shape);					shape.bounds.moveTo(pair.value.oldPosition);				}.bind(this))				this.facade.getCanvas().update();			}		});}();