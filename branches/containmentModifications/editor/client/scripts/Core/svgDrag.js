/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}new function(){	ORYX.Core.UIEnableDrag = function(event, uiObj, option){			this.uiObj = uiObj;		var upL = uiObj.bounds.upperLeft();				var a = uiObj.node.getScreenCTM();		this.faktorXY = {			x: a.a,			y: a.d		};				this.scrollNode = uiObj.node.ownerSVGElement.parentNode.parentNode;				this.offSetPosition = {			x: Event.pointerX(event) - (upL.x * this.faktorXY.x),			y: Event.pointerY(event) - (upL.y * this.faktorXY.y)		};				this.offsetScroll = {			x: this.scrollNode.scrollLeft,			y: this.scrollNode.scrollTop		};				this.dragCallback = ORYX.Core.UIDragCallback.bind(this);		this.disableCallback = ORYX.Core.UIDisableDrag.bind(this);				this.movedCallback = option ? option.movedCallback : undefined;		this.upCallback = option ? option.upCallback : undefined;				document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);			};		ORYX.Core.UIDragCallback = function(event){			var position = {			x: Event.pointerX(event) - this.offSetPosition.x,			y: Event.pointerY(event) - this.offSetPosition.y		}				position.x -= this.offsetScroll.x - this.scrollNode.scrollLeft;		position.y -= this.offsetScroll.y - this.scrollNode.scrollTop;				position.x /= this.faktorXY.x;		position.y /= this.faktorXY.y;				this.uiObj.bounds.moveTo(position);		//this.uiObj.update();				if (this.movedCallback) 			this.movedCallback(event);				Event.stop(event);			};		ORYX.Core.UIDisableDrag = function(event){		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);				if (this.upCallback) 			this.upCallback(event);				this.upCallback = undefined;		this.movedCallback = undefined;				Event.stop(event);	};	}();new function(){	/**	 * Implementation of a special drag handler	 * 	 * @class	 */	ORYX.Core.DragZone = function(el, facade){		this.facade = facade;	    ORYX.Core.DragZone.superclass.constructor.call(this, el, {shadow: !Ext.isMac});				// Init snap to grid		this.snap = new ORYX.Core.SnapToGrid();		// Init selected rect		this.rectangle = new ORYX.Core.SelectedRect(this.facade.getCanvas().getSvgContainer(), {"stroke-opacity":0.5});				// Show grid line if enabled		if (ORYX.CONFIG.SHOW_GRIDLINE) {			this.vLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_VERTICAL);			this.hLine = new ORYX.Core.GridLine(this.facade.getCanvas().getSvgContainer(), ORYX.Core.GridLine.DIR_HORIZONTAL);		}			};	ORYX.Core.DragZone.HIGHLIGHT_ATTACH = "shaperepositoy.attach";	ORYX.Core.DragZone.HIGHLIGHT_ADD = "shaperepositoy.add";	ORYX.Core.DragZone.HIGHLIGHT_CONNECTBETWEEN = "shaperepositoy.connect";	Ext.extend(ORYX.Core.DragZone, Ext.dd.DragZone, {		afterDragDrop: function(){ 	/* Can be overwritten */},		afterDragOver: function(){ 	/* Can be overwritten */},		afterDragEnter: function(){ /* Can be overwritten */},		afterValidDrop: function(){	/* Can be overwritten */},				canAttach: function(shapes, stencil){			return this.facade.getRules().canConnect({										sourceShape		: shapes[0],										edgeStencil		: stencil,										targetStencil	: stencil									});			},		canContain: function(shapes, stencil){			return this.facade.getRules().canContain({										containingShape		: shapes[0], 										containedStencil	: stencil									});			},				canConnectBetween: function(shapes, stencil){			return this.facade.getRules().canConnect({												// Source to Stencil													sourceShape		: shapes[0].getSource(),													edgeShape		: shapes[0],													targetStencil	: stencil												}) && 													this.facade.getRules().canConnect({					// Stencil to Target													sourceStencil	: stencil,													edgeShape		: shapes[0],													targetShape		: shapes[0].getTarget()												}) && 												this.facade.getRules().canContain({													containingShape		: shapes[0].getSource().parent, 													containedStencil	: stencil												});			},				canConnect: function(){			return undefined;		},						onInitDrag: function(){			this.bounds = this.getBounds() || false;						if (this.bounds){				// Set snap parameters				this.snap.setScale(this.getScale());				this.snap.setReferenceBounds(this.bounds);							this.snap.setReferenceShapes();								// Get shape to consider for snapping				if (this.snapTimer)					window.clearTimeout(this.snapTimer)								this.snapTimer = window.setTimeout(function(){					this.snap.setReferenceShapes(this.getSnapReferencedShapes());				}.bind(this), 1);								}						return ORYX.Core.DragZone.superclass.onInitDrag.apply(this, arguments);		},				onDrag: function(evt){			if (!this.rectangle||!this.bounds||this.rectangle.hidden){ 				return;			}						 var position = this.getNormalizedXY(evt);			 position = this.snapPosition(position);			 this.bounds.moveTo(position);			 this.rectangle.resize(this.bounds);		},				// private (@overwrite)	    onDragOver : function(e, id){	        var target = this.cachedTarget || Ext.dd.DragDropMgr.getDDById(id);	        if(this.beforeDragOver(target, e, id) !== false){				if (this._canAttach || this._canContain || this._canConnectBetween || this._canConnect){					this.setAllowed()				} else {					this.setNotAllowed();				}				this.updateHighlight();		            if(this.afterDragOver){	                this.afterDragOver(target, e, id);	            }	        }	    },						hide: function(){					 	this.rectangle.hide();			this.highlightShape();						if (this.vLine)				this.vLine.hide();			if (this.hLine)				this.hLine.hide();		},				show: function(){		 	this.rectangle.show();		},								/**		 * Set the proxy to an allowed state		 *		 */		setAllowed: function(){			var pr = this.getProxy();			pr.setStatus(pr.dropAllowed);			pr.sync();		},		/**		 * Set the proxy to an invalid state		 *		 */		setNotAllowed: function(){			var pr = this.getProxy();			pr.setStatus(pr.dropNotAllowed);			pr.sync();		},				/**		 * Returns the stencil which 		 * gets dragged currently		 * @return {ORYX.Core.Stencil}		 */		getDraggedStencil: function(target){			var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);			var stencilSet = this.facade.getStencilSets()[option.namespace];			return stencilSet.stencil(option.type);		},						highlightShape: function(id, element, style, color){						if (id !== undefined){				// Show Highlight				this.facade.raiseEvent({					type		: ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,					highlightId	: id,					elements	: [element],					style		: style,					color		: color				});			}						// Hide others			[ORYX.Core.DragZone.HIGHLIGHT_ATTACH, ORYX.Core.DragZone.HIGHLIGHT_ADD, ORYX.Core.DragZone.HIGHLIGHT_CONNECTBETWEEN].each(function(cId){				if (cId !== id){					this.facade.raiseEvent({						type		: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,						highlightId	: cId					});				}			}.bind(this))											},				updateHighlight: function(){						// IF OVER CANVAS			if (this._lastOverElement&&this._lastOverElement instanceof ORYX.Core.Canvas){				this.highlightShape();						// IF ATTACH			} else if (this._canAttach === true && this._lastOverElement){				this.highlightShape(						ORYX.Core.DragZone.HIGHLIGHT_ATTACH,						this._lastOverElement,						ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,						ORYX.CONFIG.SELECTION_VALID_COLOR					);						// IF ADD OR CONNECT OR CONNECT BETWEEN			} else if(this._canContain !== undefined || this._canConnectBetween !== undefined  || this._canConnect !== undefined && this._lastOverElement){				this.highlightShape(						ORYX.Core.DragZone.HIGHLIGHT_ADD,						this._lastOverElement,						undefined,						this._canContain || this._canConnectBetween || this._canConnect ? ORYX.CONFIG.SELECTION_VALID_COLOR : ORYX.CONFIG.SELECTION_INVALID_COLOR					);								} else {				this.highlightShape();			}		},				setOptions: function(options){			Ext.apply(Ext.dd.Registry.getHandle(this.DDM.currentTarget), options);		},				updateOptions: function(options, event){						// Can...			options.canContain 			= !!this._canContain;			options.canAttach 			= !!this._canAttach;			options.canConnectBetween 	= !!this._canConnectBetween;			options.canConnect 			= !!this._canConnect;						// Update position			var pos;			try {				pos = this.bounds.center();				} catch(e){				pos = this.getNormalizedXY(event);			}									// Add parent			if (this._canContain&&!this._canAttach&&!this._canConnectBetween&&this._lastOverElement){				options.parent = this._lastOverElement;			} else {				delete options.parent;			}			// Add connect between			if (this._canConnectBetween&&!this._canAttach&&this._lastOverElement){				options.parent = this._lastOverElement.getSource().parent;				var seg = this._lastOverElement.findSegment(pos);				if (seg){					pos = ORYX.Core.Math.getPointOfIntersectionPointLine(seg.fromDocker.bounds.center(), seg.toDocker.bounds.center(), pos);				}			}									// Update offset			if (options.parent){				// Correct position of parent				var parentAbs = options.parent.absoluteXY();				pos.x -= parentAbs.x; pos.y -= parentAbs.y;			}			// If connect			if (this._canConnect){				options.parent = this._lastOverElement;			}							// Set position			options.position = pos						return options;		},				// private		beforeDragDrop: function(){ },				// private		beforeDragEnter: function(){			if (!this.rectangle||!this.bounds){				return;			}		 	this.show()		},				// private		beforeDragOut: function(){			// Remove last selected element			delete this._lastOverElement;						if (!this.rectangle||!this.bounds){				return;			}		 	this.hide();		},						// private		beforeDragOver: function(target, event){			// Get the coordinates and shapes at this position				var coord = this.facade.eventCoordinates(event.browserEvent);			var aShapes = this.facade.getCanvas().getAbstractShapesAtPosition( coord );				if(aShapes.length === 0) {				return;			}							//			var el = aShapes.last();					// Get the upper element				var parentCandidates = aShapes.reverse().findAll(function(candidate) {					return (candidate instanceof ORYX.Core.Canvas 							|| candidate instanceof ORYX.Core.Node							|| candidate instanceof ORYX.Core.Edge);				});															// Get the current stencil			var stencil = this.getDraggedStencil(target);						// Get candidate			var parentCandidate = parentCandidates[0];						if (parentCandidate !== this._lastOverElement){				delete this._canAttach;				delete this._canContain;				delete this._canConnectBetween;				delete this._canConnect;				this._lastOverElement = parentCandidate;						} else if(parentCandidate === this._lastOverElement && (stencil.type() === "edge" || this._canAttach === false)){				return;			}						if (!parentCandidate){				this.updateHighlight();				this.setNotAllowed();				return;			}				// Node			if(stencil.type() === "node") {								/**				 	 * Check Attachments			 	 */			 	if (parentCandidate instanceof ORYX.Core.Node && parentCandidate.isPointOverOffset(coord.x, coord.y) && this._canAttach === undefined) {					this._canAttach = this.canAttach(parentCandidates, stencil);					delete this._canContain;						}								/**				 	 * Check Containment			 	 */				if (this._canContain === undefined && (!this._canAttach || (parentCandidate instanceof ORYX.Core.Node && !parentCandidate.isPointOverOffset(coord.x, coord.y)))) {					this._canContain = this.canContain(parentCandidates, stencil);					delete this._canAttach;				}												/**				 	 * Check Connect between (if candidate is an edge)			 	 */				if (parentCandidate instanceof ORYX.Core.Edge && this._canConnectBetween === undefined && this._canContain !== true && this._canAttach !== true) {					this._canConnectBetween = this.canConnectBetween(parentCandidates, stencil);				}				// Edge			} else { 								/**				 	 * Check Connect			 	 */				if (this._canConnect === undefined) {					this._canConnect = this.canConnect(parentCandidates, stencil);				}								if (this._canConnect === undefined){					this._canContain = true;					this._lastOverElement = this.facade.getCanvas();				}			}		},				// private (@overwrite)	    onDragDrop : function(e, id){				        var target = this.cachedTarget || Ext.dd.DragDropMgr.getDDById(id);			this.cachedTarget = false;			this.proxy.hide();						var option = this.updateOptions(Ext.dd.Registry.getHandle(target.DDM.currentTarget), e);			option = Object.clone(option);				        if(this.beforeDragDrop(target, e, id) !== false){	            if(target.isNotifyTarget){	                if(this.getProxy().dropStatus === this.getProxy().dropAllowed && this._lastOverElement){ // valid drop?	                    this.onValidDrop(option, this._lastOverElement, e);	                }else{						this.hide();	                    this.onInvalidDrop(target, e, id);	                }	            }else{	                this.onValidDrop(target, e, id);	            }	            	            if(this.afterDragDrop){					this.afterDragDrop(target, e, id)	            }	        }	        delete this.cachedTarget;	    },				onValidDrop : function(option, shape, event){	        this.hideProxy();	        if(this.afterValidDrop){				window.setTimeout(function(){               		this.afterValidDrop.apply(this, arguments);								this.hide();				}.bind(this, option, shape, event), 1)	        }	    },				// private (@overwrite)		afterRepair: function(){			this.dragging = false;		},					/**		 *		 * @return {Array} Shapes which should be considered for snapping		 */	 		getSnapReferencedShapes: function(){							return this.facade.getCanvas().getChildShapes(true);					},				/**		 *		 * @return {Object} Returns a x/y coordinate normalized to the canvas		 */		getNormalizedXY: function(evt){						var xy = evt.getXY();			var pos = {x: xy[0], y: xy[1]};				var a = this.facade.getCanvas().node.getScreenCTM();						// Correcting the UpperLeft-Offset			pos.x -= a.e; pos.y -= a.f;			// Correcting the Zoom-Faktor			pos.x /= a.a; pos.y /= a.d;									var mid = this.bounds ? this.bounds.midPoint() : {x:0, y:0};						// Set that the position is not lower than zero			pos.x = Math.max( mid.x , pos.x )			pos.y = Math.max( mid.y , pos.y )				// Set that the position is not bigger than the canvas			var c = this.facade.getCanvas();			pos.x = Math.min( c.bounds.width() - mid.x, 	pos.x)			pos.y = Math.min( c.bounds.height() - mid.y, 	pos.y)										return pos;		},				snapPosition: function(pos){						// Adjust by midpoint			var mid = this.bounds.midPoint();			pos.x -= mid.x; pos.y -= mid.y;						var hor, ver;			var onHor = function(x){hor = x}.bind(this);			var onVer = function(y){ver = y}.bind(this);			pos = this.snap.adjustPoint(pos, onHor, onVer);						if (this.hLine&&this.vLine){				if (hor === undefined){ this.hLine.hide() } else { this.hLine.update(hor) }				if (ver === undefined){ this.vLine.hide() } else { this.vLine.update(ver) }			}						return pos;		},				/**		 * Return the scale factor of the canvas		 * @return {int}		 */ 		getScale: function(){			try {				return this.facade.getCanvas().node.transform.baseVal.getItem(0).matrix.a;			} catch(e) {				return 1;			}		},			/**		 * Return the bounds of a new shape		 * @return {ORYX.Core.Bounds}		 */		getBounds: function(){			var option = Ext.dd.Registry.getHandle(this.DDM.currentTarget);			var stencil = this.facade.getStencilSets()[option.namespace].stencil(option.type);						if (stencil.type() != "node"){				return;			}						return new ORYX.Core.Node({}, stencil).bounds.clone();		}	});				/**	 * Implementation of some helper methods	 * for snap to grid. Mainly to adjust a point	 * to the currently related shapes.	 * @class ORYX.Core.SnapToGrid	 * 	 */	ORYX.Core.SnapToGrid = Clazz.extend({			construct: function(){			this.points = [];			this.scale = 1;			this.bounds = undefined;					},				setReferenceShapes: function(shapes){						if (this.timer)				window.clearTimeout(this.timer);							this.points = [];						if (!(shapes instanceof Array) || shapes.length == 0){				return;			}						this.timer = window.setTimeout(function(){								// For all these shapes				shapes.each((function(value) {					if(!(value instanceof ORYX.Core.Edge)) {						var ul 		= value.absoluteXY();						var width 	= value.bounds.width();						var height 	= value.bounds.height();						// Add the upperLeft, center and lowerRight - Point to the distancePoints						this.points.push({							ul: {								x: ul.x,								y: ul.y							},							c: {								x: ul.x + (width / 2),								y: ul.y + (height / 2)							},							lr: {								x: ul.x + width,								y: ul.y + height							}						});					}				}).bind(this));							}.bind(this), 1);		},				setReferenceBounds: function(bounds){			this.bounds = bounds || undefined;		},			setScale: function(scale){			this.scale = scale || 1;		},					adjustPoint: function(point, adjustedHorizontalClb, adjustedVerticalClb){						// Get the current Bounds			var bounds = this.bounds;			if (!bounds){				return;			}						var ulThres = 6;			var cThres 	= 16;			var lrThres = 6;				var scale = this.scale;						var ul 	= { x: (point.x/scale), y: (point.y/scale)};			var c 	= { x: (point.x/scale) + (bounds.width()/2), y: (point.y/scale) + (bounds.height()/2)};			var lr 	= { x: (point.x/scale) + (bounds.width()), y: (point.y/scale) + (bounds.height())};				var offsetX, offsetY;			var gridX, gridY;						// For each distant point			this.points.each(function(value) {					var x, y, gx, gy;				if (Math.abs(value.c.x-c.x) < cThres){					x = value.c.x-c.x;					gx = value.c.x;				}/* else if (Math.abs(value.ul.x-ul.x) < ulThres){					x = value.ul.x-ul.x;					gx = value.ul.x;				} else if (Math.abs(value.lr.x-lr.x) < lrThres){					x = value.lr.x-lr.x;					gx = value.lr.x;				} */									if (Math.abs(value.c.y-c.y) < cThres){					y = value.c.y-c.y;					gy = value.c.y;				}/* else if (Math.abs(value.ul.y-ul.y) < ulThres){					y = value.ul.y-ul.y;					gy = value.ul.y;				} else if (Math.abs(value.lr.y-lr.y) < lrThres){					y = value.lr.y-lr.y;					gy = value.lr.y;				} */					if (x !== undefined) {					offsetX = offsetX === undefined ? x : (Math.abs(x) < Math.abs(offsetX) ? x : offsetX);					if (offsetX === x)						gridX = gx;				}					if (y !== undefined) {					offsetY = offsetY === undefined ? y : (Math.abs(y) < Math.abs(offsetY) ? y : offsetY);					if (offsetY === y)						gridY = gy;				}			});									if (offsetX !== undefined) {				ul.x += offsetX;					ul.x *= scale;				if (gridX!==undefined&&adjustedVerticalClb instanceof Function)					adjustedVerticalClb(gridX);			} else {				ul.x = (point.x - (point.x % (ORYX.CONFIG.GRID_DISTANCE/2)));			}						if (offsetY !== undefined) {					ul.y += offsetY;				ul.y *= scale;				if (this.hLine&&gridY)					this.hLine.update(gridY);				if (gridY!==undefined&&adjustedHorizontalClb instanceof Function)					adjustedHorizontalClb(gridY);			} else {				ul.y = (point.y - (point.y % (ORYX.CONFIG.GRID_DISTANCE/2)));			}						return ul;		}			});		/**	 * Implementation of a selection rectangle	 * Mainly to show current selection or drag area	 * @class	 * 	 */ 	ORYX.Core.SelectedRect = Clazz.extend({			construct: function(parentId, options) {				this.parentId = parentId;				this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", $(parentId),						['g']);				this.dashedArea = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,				['rect', Ext.apply({x: 0, y: 0,					'fill'				: 'none',					'stroke'			: '#777777', 					'stroke-width'		: 1, 					'stroke-dasharray'	: '3,3',					'shape-rendering'	: 'crispEdges',					'pointer-events'	: 'none'}, options ||{})]);				this.hide();			},			hide: function() {			this.node.setAttributeNS(null, 'display', 'none');			this.hidden = true;		},			show: function() {			this.node.setAttributeNS(null, 'display', '');			this.hidden = false;			this.dashedArea.setAttributeNS(null, 'stroke-width', Math.max(1, (1/this.getScale()) || 1));		},				getScale: function(){			return this.node.getScreenCTM().a || 1;		},			resize: function(bounds) {			var upL = bounds.upperLeft();				var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;				this.dashedArea.setAttributeNS(null, 'width', (bounds.width() + 2*padding) + 1);			this.dashedArea.setAttributeNS(null, 'height', (bounds.height() + 2*padding) + 1);			this.node.setAttributeNS(null, 'transform', "translate("+ (upL.x - padding - 1) +", "+ (upL.y - padding - 1) +")");		}			});				/**	 * Implementation of gridlines	 * Horizontal or vertical are available	 * 	 * @class ORYX.Plugins.GridLine	 * 	 */	ORYX.Core.GridLine = Clazz.extend({				construct: function(parentId, direction) {				if (ORYX.Core.GridLine.DIR_HORIZONTAL !== direction && ORYX.Core.GridLine.DIR_VERTICAL !== direction) {				direction = ORYX.Plugins.GridLine.DIR_HORIZONTAL			}								this.parent = $(parentId);			this.direction = direction;			this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent,						['g']);				this.line = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,				['path', {					'fill'				: 'none',					'stroke'			: 'silver', 					'stroke-width'		: 1, 					'stroke-dasharray'	: '5,5',					'shape-rendering'	: 'crispEdges',					'pointer-events'	: 'none'}]);				this.hide();			},			hide: function() {			this.node.setAttributeNS(null, 'display', 'none');		},			show: function() {			this.node.setAttributeNS(null, 'display', '');			this.line.setAttributeNS(null, 'stroke-width', Math.max(1, (1/this.getScale()) || 1));		},			getScale: function(){			try {				return this.node.getScreenCTM().a || 1;			} catch(e) {				return 1;			}		},				update: function(pos) {						if (this.direction === ORYX.Core.GridLine.DIR_HORIZONTAL) {				var y = pos instanceof Object ? pos.y : pos; 				var cWidth = this.parent.parentNode.parentNode.width.baseVal.value/this.getScale();				this.line.setAttributeNS(null, 'd', 'M 0 '+y+ ' L '+cWidth+' '+y);			} else {				var x = pos instanceof Object ? pos.x : pos; 				var cHeight = this.parent.parentNode.parentNode.height.baseVal.value/this.getScale();				this.line.setAttributeNS(null, 'd', 'M'+x+ ' 0 L '+x+' '+cHeight);			}						this.show();		}			});		/**	 * Some statics	 */	ORYX.Core.GridLine.DIR_HORIZONTAL = "hor";	ORYX.Core.GridLine.DIR_VERTICAL = "ver";			/**	 * Implementation of a command which	 * add all children from the same parent to it.	 * 	 * @param {facade} facade	 * @param {ORYX.Core.Shape} shape	 * @param {boolean} alsoRemove Indicated if also the childs have to be removed from the shape which are outside or not	 */	ORYX.Core.EnsureChildCommand = ORYX.Core.Command.extend({					construct: function(facade, shapes, alsoRemove){				this.shapes 	= shapes instanceof Array ? shapes : [shapes];				this.facade 	= facade;				this.alsoRemove = alsoRemove === true;				this.changes;			},						execute: function(){								if (!ORYX.CONFIG.CONTAIN_AUTOMATICALY){ return; }								if (this.changes){					this.exectueAgain();					return;				}								// Get all children (all elements from the canvas and all children of the shapes parent)				var children = [].concat(this.facade.getCanvas().getChildNodes());				this.shapes.each(function(shape){					if (!(shape.parent instanceof ORYX.Core.Canvas)){						children = children.concat(shape.parent.getChildNodes());					}				});				children = children.uniq();												var shapes = [];				this.shapes.each(function(shape){					// Get the most top element 					// which is not the canvas					var mostTopShape = shape;					while(mostTopShape&&!(mostTopShape.parent instanceof ORYX.Core.Canvas)){						mostTopShape = mostTopShape.parent;					}										// The shapes which might be one of the parent					// could be all shapes from the most top, or the shape themselves					if (mostTopShape&&!shapes.include(mostTopShape)){						var ch = mostTopShape.getChildNodes(true).reverse();						ch = ch.findAll(function(child){							return this.facade.getRules().isContainer(child)						}.bind(this))						shapes = shapes.concat(shape, mostTopShape, ch);					}				}.bind(this));				shapes = shapes.uniq();								// Cache the absolute bounds 				var sBounds = {};				this.changes = $H({});								/**				 * If also removing is wished				 */				if (this.alsoRemove){					shapes.each(function(shape){						// Cache the absolute bounds						if (!sBounds[shape.getId()]){							sBounds[shape.getId()] = shape.absoluteBounds();						}						var bounds = sBounds[shape.getId()];						var childs = shape.getChildNodes();												childs.each(function(child){							var ul = child.absoluteXY();							var lr = {x:ul.x+child.bounds.width(), y:ul.y+child.bounds.height()};							if (!bounds.isIncluded(ul, 2)&&!bounds.isIncluded(lr, 2)){								var parent = this.getContainerParent(shape.parent, child);								if (parent){									this.add(parent, child, sBounds[parent.getId()] || parent.absoluteBounds());									children.push(child); // Add to childs to consider								}							}						}.bind(this))					}.bind(this))				}								// For every considered shape				children.each(function(child){										// Get position					var ul = child.absoluteXY();					var lr = {x:ul.x+child.bounds.width(), y:ul.y+child.bounds.height()};										// Iterate over all possible parent shapes								shapes.any(function(parent){						// Check if parent is child						var c = child;						while(c && !(c instanceof ORYX.Core.Canvas)){						    if (c === parent){ return false; }							c = c.parent;						}												// Check if child is parent						var c = parent;						while(c && !(c instanceof ORYX.Core.Canvas)){						    if (c === child){ return false; }							c = c.parent;						}												// Cache the absolute bounds						if (!sBounds[parent.getId()]){							sBounds[parent.getId()] = parent.absoluteBounds();						}						var bounds = sBounds[parent.getId()];												// Check if the child is within the parent						if (bounds.isIncluded(ul, -2) && bounds.isIncluded(lr, -2)){														// Check if the child can be contained in the parent							if (this.facade.getRules().canContain({containingShape:parent,containedShape:child})){								this.add(parent, child, bounds);								return true;							}						}						return false;					}.bind(this));				}.bind(this));								this.facade.getCanvas().update();			},						add: function(parent, child, bounds){				// If all TRUE, adds it				var cUl = child.absoluteXY();				var pUl = bounds.upperLeft();				var pos = {x:cUl.x-pUl.x, y:cUl.y-pUl.y}				var oldParent = this.changes[child.getId()] ? this.changes[child.getId()].oldParent : child.parent;				var oldPosition = this.changes[child.getId()] ? this.changes[child.getId()].oldPosition : child.bounds.upperLeft();								// Cache changes for rollback				this.changes[child.getId()] = {											shape		: child,											oldParent	: oldParent,											oldPosition	: oldPosition,											newParent	: parent,											newPosition	: pos										}								parent.add(child);				child.bounds.moveTo(pos);					},						getContainerParent: function(parent, shape){				while(parent && !this.facade.getRules().canContain({containingShape:parent,containedShape:shape})){					parent = parent.parent;				}				return parent;			},						exectueAgain: function(){				// Iterate over all changes and rollback				this.changes.each(function(pair){					var parent = pair.value.newParent;					var shape = pair.value.shape;					parent.add(shape);					shape.bounds.moveTo(pair.value.newPosition);				}.bind(this))				this.facade.getCanvas().update();			},						rollback: function(){								if (!ORYX.CONFIG.CONTAIN_AUTOMATICALY){ return; }								// Iterate over all changes and rollback				this.changes.each(function(pair){					var parent = pair.value.oldParent;					var shape = pair.value.shape;					parent.add(shape);					shape.bounds.moveTo(pair.value.oldPosition);				}.bind(this))				this.facade.getCanvas().update();			}		});				/**	 * Implements a command to move docker by an offset.	 * 	 * @class ORYX.Core.MoveDockersCommand	 * @param {Object} object An object with the docker id as key and docker and offset as object value	 * 	 */		ORYX.Core.MoveDockersCommand = ORYX.Core.Command.extend({		construct: function(dockers){			this.dockers 	= $H(dockers);			this.edges 		= $H({});		},		execute: function(){			if (this.changes) {				this.executeAgain();				return;			} else {				this.changes = $H({});			}						this.dockers.values().each(function(docker){				var edge = docker.docker.parent;				if (!this.changes[edge.getId()]) {					this.changes[edge.getId()] = {						edge				: edge,						oldDockerPositions	: edge.dockers.map(function(r){ return r.bounds.center() })					}				}				docker.docker.bounds.moveBy(docker.offset);				this.edges[edge.getId()] = edge;				docker.docker.update();			}.bind(this));			this.edges.each(function(edge){				edge.value._update(true);				if (this.changes[edge.value.getId()])					this.changes[edge.value.getId()].dockerPositions = edge.value.dockers.map(function(r){ return r.bounds.center() })			}.bind(this));		},		executeAgain: function(){			this.changes.values().each(function(change){				// Reset the dockers				this.removeAllDocker(change.edge);				change.dockerPositions.each(function(pos, i){						if (i==0||i==change.dockerPositions.length-1){ return }										var docker = change.edge.createDocker(undefined, pos);					docker.bounds.centerMoveTo(pos);					docker.update();				}.bind(this));				change.edge._update(true);			}.bind(this));		},		rollback: function(){			this.changes.values().each(function(change){				// Reset the dockers				this.removeAllDocker(change.edge);				change.oldDockerPositions.each(function(pos, i){						if (i==0||i==change.oldDockerPositions.length-1){ return }										var docker = change.edge.createDocker(undefined, pos);					docker.bounds.centerMoveTo(pos);					docker.update();				}.bind(this));				change.edge._update(true);			}.bind(this));		},		removeAllDocker: function(edge){			edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){				edge.removeDocker(docker);			})		}	});		}();