/** * Copyright (c) 2007 * Kerstin Pfitzner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Transforms a BPMNplus diagram to its XPDL4Chor representation and * calls a transformation web service to generate BPEL4Chor from the XPDL4Chor * representation. */ORYX.Plugins.Bpel4ChorTransformation = Clazz.extend({	facade: undefined,		dialogSupport: undefined,		/**	 * Offers the plugin functionality:	 * 	- generation of XPDL4Chor	 * 	- generation of BPEL4Chor	 * 	 * Registers for a ORYX.CONFIG.EVENT_PROPERTY_CHANGED event to react to changed	 * element properties.	 */	construct: function(facade) {				this.facade = facade;        		this.dialogSupport = new ORYX.Plugins.TransformationDownloadDialog();				this.facade.offer({			'name':ORYX.I18N.Bpel4ChorTransformation.exportBPEL,			'functionality': this.transformBPEL4Chor.bind(this),			'group': ORYX.I18N.Bpel4ChorTransformation.group,			'icon': ORYX.PATH + "images/export_multi.png",			'description': ORYX.I18N.Bpel4ChorTransformation.exportBPELDesc,			'index': 1,			'minShape': 0,			'maxShape': 0});					this.facade.offer({			'name':ORYX.I18N.Bpel4ChorTransformation.exportXPDL,			'functionality': this.transformXPDL4Chor.bind(this),			'group': ORYX.I18N.Bpel4ChorTransformation.group,			'icon': ORYX.PATH + "images/export.png",			'description': ORYX.I18N.Bpel4ChorTransformation.exportXPDLDesc,			'index': 2,			'minShape': 0,			'maxShape': 0});					this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.propertyChanged.bind(this));	},		// check if changed property does affect the transformability	/**	 * Reacts to a changed property in the property window, since this may cause	 * errors during the transformation.	 * 	 * If the name of a receiving activity was changed:	 *  - Determine all other receiving activities with an incoming message 	 *    flow to the same source activity 	 *  - If these receiving activities do not have the same name, print out	 *    a warning in a message dialog.	 *    	 * If the loop type of a receive task was changed:	 * 	- Check if the receive task is located directly after an event-based	 *    decision gateway	 *  - If so, print out a warning in a message dialog, because a looping 	 *    task is not allowed after an event-based decision gateway in BPMNplus	 * 	 * @param {Object} args 	 * 	- args.element: the changed shape	 *  - args.name:    the name of the changed property	 */	propertyChanged: function(args) {			var shape = args.element;		var stencil = shape.getStencil();		if (args.name == "oryx-name") {			if ((stencil.id() == stencil.namespace() + "ReceiveTask") || 			 (stencil.id() == stencil.namespace() + "IntermediateMessageEvent") || 			 (stencil.id() == stencil.namespace() + "StartMessageEvent")) {								// get all receiving activities with same source				var receiving = new Hash();				shape.getIncomingShapes().each(function(edge) { 					if (edge.getStencil().id() == edge.getStencil().namespace() + "MessageFlow") {						var sources = edge.getIncomingShapes();						sources.each(function(source) {							// get target of all outgoing message flows							source.getOutgoingShapes().each(function(edgeSource) {								if (edgeSource.getStencil().id() == edgeSource.getStencil().namespace() + "MessageFlow") {									var list = receiving[source.resourceId];									if (list == undefined) {										list = new Array();									}									list = list.concat(edgeSource.getOutgoingShapes());									receiving[source.resourceId] = list;								}							});						});					}				});								var name = null				var values = receiving.values();				for (var i = 0; i < values.length; i++) {					var list = values[i];					for (var j = 0; j < list.length; j++) {						var shape = list[j];						if (name == undefined) {							name = list[j].properties["oryx-name"];						} else if (name != list[j].properties["oryx-name"]) {							this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.warning,								ORYX.I18N.Bpel4ChorTransformation.wrongValue.replace(/1/, name));							return;						}					}				}			}		} else if (args.name == "oryx-looptype") {					// if parent of receive task is event-based decision gateway			// the loop type should be None to be transformable to BPEL4Chor			if (stencil.id() == stencil.namespace() + "ReceiveTask") {				// get incoming sequence flows				shape.getIncomingShapes().each(function(edge) { 					if (edge.getStencil().id() == edge.getStencil().namespace() + "SequenceFlow") {						// get source of sequence flows						var sources = edge.getIncomingShapes();						sources.each(function(source) {							if (source.getStencil().id() == stencil.namespace() + "Exclusive_Eventbased_Gateway") {								if (shape.properties["oryx-looptype"] != "None") {									this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.warning, ORYX.I18N.Bpel4ChorTransformation.loopNone);									 return;								}							}						});					}				});			}		}	},		/**	 * Checks if all edges have a source and a target element. 	 * If not print out an error in a message dialog.	 * 	 * The check is necessary because such edges would lead to a parser	 * error during the transformation.	 */	validate: function() {		// check if all edges have a source and a target		var edges = this.facade.getCanvas().getChildEdges();		for (var i = 0; i < edges.size(); i++) {			var edge = edges[i];			var name = edge.getStencil().title();			var id = edge.properties["oryx-id"];			if (edge.getIncomingShapes().size() == 0) {				this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.error, ORYX.I18N.Bpel4ChorTransformation.noSource.replace(/1/, name).replace(/2/, id));				return false;			} else if (edge.getOutgoingShapes().size() == 0) {				this.dialogSupport.openMessageDialog(					ORYX.I18N.Bpel4ChorTransformation.error, ORYX.I18N.Bpel4ChorTransformation.noTarget.replace(/1/, name).replace(/2/, id));				return false;			}			}		return true;	},		/**	 * Since canvas properties are not serialized they can not be	 * transformed using xslt. Thus, they will be added after the	 * xslt transformation using this method.	 * 	 * @param {Object} xpdl4chor The generated xpdl4chor document	 */	addCanvasProperties: function(xpdl4chor) {		// chor:TargetNamespace		var canvas = this.facade.getCanvas();		var targetNamespace = xpdl4chor.createAttribute("chor:TargetNamespace");		targetNamespace.value = canvas.properties["oryx-targetNamespace"];		xpdl4chor.documentElement.setAttributeNode(targetNamespace);				// Name		var name = xpdl4chor.createAttribute("Name");		name.value = canvas.properties["oryx-name"];		xpdl4chor.documentElement.setAttributeNode(name);				// Id		var idAttr = xpdl4chor.createAttribute("Id");		var id = canvas.properties["oryx-id"];		if (id == "") {			id = DataManager.__provideId();		}		idAttr.value = id;		xpdl4chor.documentElement.setAttributeNode(idAttr);				// PackageHeader.Created		var created = xpdl4chor.createElement("xpdl:Created");		var createdText = document.createTextNode(canvas.properties["oryx-creationdate"]);		created.appendChild(createdText);		var parent = xpdl4chor.documentElement.firstChild;		parent.appendChild(created);				// RedefinableHeader		var expressionLanguage = canvas.properties["oryx-expressionlanguage"];		var queryLanguage = canvas.properties["oryx-querylanguage"];				var header = xpdl4chor.createElement("xpdl:RedefinableHeader");		if (queryLanguage != "") {			var queryLangAttr = xpdl4chor.createAttribute("chor:QueryLanguage");			queryLangAttr.value = queryLanguage;			header.setAttributeNode(queryLangAttr);		}		if (expressionLanguage != "") {			var expressionLangAttr = xpdl4chor.createAttribute("chor:ExpressionLanguage");			expressionLangAttr.value = expressionLanguage;			header.setAttributeNode(expressionLangAttr);		}		// append header after first child (PackageHeader node)		xpdl4chor.documentElement.insertBefore(header, xpdl4chor.documentElement.firstChild.nextSibling);	},			/**	 * Builds up the data that will be shown in the result dialog of	 * the XPDL4Chor transformation.	 * 	 * @param {String} xpdl4chor The generated XPDL4Chor.	 */	buildXPDL4ChorData: function(xpdl4chor) {		var data = [		    ["XPDL4Chor", xpdl4chor, this.dialogSupport.getResultInfo(xpdl4chor)]		];				return data;	},			/**	 * Builds up the data that will be shown in the result dialog of	 * the BPEL4Chor transformation.	 * For this purpose the process names are determined and	 * it is checked if the topology and process were generated	 * successfully.	 * 	 * @param {String} topology    The generated topology 	 * @param {String[]} processes The generated processes	 */	buildTransData: function(topology, processes) {		var data = [		    ["topology", topology, this.dialogSupport.getResultInfo(topology)]		];				for (var i = 0; i < processes.length; i++) {			var name = this.dialogSupport.getProcessName(processes[i]);			if (name == undefined) {				name = "Process " + (i+1);			}			data[i+1] = [name, processes[i], this.dialogSupport.getResultInfo(processes[i])];		}					return data;	},			/**	 * Analyzes the result of the servlet call.	 * 	 * If an fault occured or the answer is undefined, the error is shown	 * using a message dialog.	 * 	 * If the first result starts with "ParserError" the error is shown using an 	 * error dialog. Otherwise the result is shown using the result dialog.	 * 	 * @param {Object} result - the result of the transformation servlet (JSON)	 */	displayResult: function(result) {		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});		var resultString = '(' + result + ')';		var resultObject;				try {			resultObject = eval(resultString);		} catch (e1) {			alert("Error during evaluation of result: " + e1 + "\r\n" + resultString);		}				if ((!resultObject.res) || (resultObject.res.length == 0)) {			this.dialogSupport.openMessageDialog(ORYX.I18N.TransformationDownloadDialog.error,ORYX.I18N.TransformationDownloadDialog.noResult);		} else if (resultObject.res[0].content.indexOf("Parser Error")>0) {			this.dialogSupport.openErrorDialog(resultObject.res[0].content);		} else {			var topology = resultObject.res[0].content;			var processes = new Array();			for (var i = 1; i < resultObject.res.length; i++) {				processes[i-1] = resultObject.res[i].content;			}			var data = this.buildTransData(topology, processes);			this.dialogSupport.openResultDialog(data);		}	},			/**	 * Transforms the model to XPDL4Chor using the xslt stylesheet.	 * After that the web service for the transformation to BPEL4Chor	 * will be called.	 * 	 * @param {Object} xpdlOnly True, if only the XPDL4Chor should be 	 *                          generated, false otherwise	 */	transform: function(xpdlOnly) {				var valid = this.validate();	   	if (!valid) {			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});			Ext.Msg.alert("Transformation","input not valid");			return null;		}				var xsltProcessor = new XSLTProcessor();				var xslRef = document.implementation.createDocument("", "", null);		var index = location.href.lastIndexOf("/");		var xslt = location.href.substring(0, index) + "/xslt/BPMNplus2XPDL4Chor.xslt";				xslRef.onload = function() {			// import the .xsl and do transformation			xsltProcessor.importStylesheet(xslRef);					var serializedDOM = DataManager.serializeDOM(this.facade);							// single parent node needed to parse the DOM			serializedDOM = "<data>" + serializedDOM + "</data>";		  					var parser=new DOMParser();			var doc=parser.parseFromString(serializedDOM,"text/xml");						try {				var xpdl4chor = xsltProcessor.transformToDocument(doc);			} catch (error) {				this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.error, ORYX.I18N.Bpel4ChorTransformation.noGen.replace(/1/, error.name).replace(/2/, error.message));				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});				return null;			}						this.addCanvasProperties(xpdl4chor);						var serialized = (new XMLSerializer()).serializeToString(xpdl4chor);			serialized = serialized.startsWith("<?xml") ? serialized : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized;			if (xpdlOnly) {				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});								var data = this.buildXPDL4ChorData(serialized);				this.dialogSupport.openResultDialog(data);			} else {				var target = "http://" + location.host + ORYX.CONFIG.XPDL4CHOR2BPEL4CHOR_TRANSFORMATION_URL;				try {					Ext.Ajax.request({						method : "POST",						url : target,						params : {data: serialized},						success : function(response, options) {							this.displayResult(response.responseText);						}.bind(this)					});				} catch (e) {					alert("Error during call of transformation: " + e);				}			}		}.bind(this);				xslRef.load(xslt);	},		/**	 * Transform the model to its XPDL4Chor representation.	 */	transformXPDL4Chor: function() { 				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.Bpel4ChorTransformation.loadingXPDL4ChorExport});		this.transform(true);	},  	/**  	 * Transform the model to its BPELChor representation.  	 */	transformBPEL4Chor: function(){ 	   		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.Bpel4ChorTransformation.loadingBPEL4ChorExport});		this.transform(false);			}});