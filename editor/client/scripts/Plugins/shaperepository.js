/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins) {	ORYX.Plugins = new Object();}ORYX.Plugins.ShapeRepository = {	facade: undefined,	construct: function(facade) {		this.facade = facade;		this._currentParent;		this._canContain = undefined;		this._canAttach  = undefined;		this.shapeList = new Ext.tree.TreeNode({					})		var panel = new Ext.tree.TreePanel({            cls:'shaperepository',			loader: new Ext.tree.TreeLoader(),			root: this.shapeList,			autoScroll:true,			rootVisible: false,			lines: false,			anchors: '0, -30'		})		var region = this.facade.addToRegion("west", panel, ORYX.I18N.ShapeRepository.title);					// Create a Drag-Zone for Drag'n'Drop		var DragZone = new ORYX.Core.DragZone(this.shapeList.getUI().getEl(), this.facade);		DragZone.afterValidDrop = this.drop.bind(this);				// Load all Stencilssets		this.setStencilSets();				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, this.setStencilSets.bind(this));	},		/**	 * Load all stencilsets in the shaperepository	 */	setStencilSets: function() {		// Remove all childs		var child = this.shapeList.firstChild;		while(child) {			this.shapeList.removeChild(child);			child = this.shapeList.firstChild;		}		// Go thru all Stencilsets and stencils		this.facade.getStencilSets().values().each((function(sset) {						// For each Stencilset create and add a new Tree-Node			var stencilSetNode						var typeTitle = sset.title();			var extensions = sset.extensions();			if (extensions && extensions.size() > 0) {				typeTitle += " / " + ORYX.Core.StencilSet.getTranslation(extensions.values()[0], "title");			} 						this.shapeList.appendChild(stencilSetNode = new Ext.tree.TreeNode({				text:typeTitle, 			// Stencilset Name				allowDrag:false,        		allowDrop:false,           				iconCls:'headerShapeRepImg',	            cls:'headerShapeRep',				singleClickExpand:true}));						stencilSetNode.render();			stencilSetNode.expand();							// Get Stencils from Stencilset			var stencils = sset.stencils(this.facade.getCanvas().getStencil(),										 this.facade.getRules());				var treeGroups = new Hash();						// For each stencil			stencils.each((function(value) {								// Show stencils in no group if there is less than 10 shapes				if(stencils.length <= ORYX.CONFIG.MAX_NUM_SHAPES_NO_GROUP) {					this.createStencilTreeNode(stencilSetNode, value);						return;									}								// Get the groups name				var groups = value.groups();								// For each Group-Entree				groups.each((function(group) {										// If there is a new group					if(!treeGroups[group]) {						// Create a new group						treeGroups[group] = new Ext.tree.TreeNode({							text:group,					// Group-Name							allowDrag:false,        					allowDrop:false,            							iconCls:'headerShapeRepImg', // Css-Class for Icon				            cls:'headerShapeRepChild',  // CSS-Class for Stencil-Group							singleClickExpand:true});												// Add the Group to the ShapeRepository						stencilSetNode.appendChild(treeGroups[group]);						treeGroups[group].render();						}										// Create the Stencil-Tree-Node					this.createStencilTreeNode(treeGroups[group], value);										}).bind(this));												// If there is no group				if(groups.length == 0) {					// Create the Stencil-Tree-Node					this.createStencilTreeNode(stencilSetNode, value);										}				}).bind(this));		}).bind(this));					if (this.shapeList.firstChild.firstChild) {			this.shapeList.firstChild.firstChild.expand(false, true);		}		},	createStencilTreeNode: function(parentTreeNode, stencil) {		// Create and add the Stencil to the Group		var newElement = new Ext.tree.TreeNode({				text:		stencil.title(), 		// Text of the stencil				icon:		stencil.icon(),			// Icon of the stencil				allowDrag:	false,					// Don't use the Drag and Drop of Ext-Tree				allowDrop:	false,				iconCls:	'ShapeRepEntreeImg', 	// CSS-Class for Icon				cls:		'ShapeRepEntree'		// CSS-Class for the Tree-Entree				});		parentTreeNode.appendChild(newElement);				newElement.render();							var ui = newElement.getUI();				// Set the tooltip		ui.elNode.setAttributeNS(null, "title", stencil.description());				// Register the Stencil on Drag and Drop		Ext.dd.Registry.register(ui.elNode, {				node: 		ui.node,		        handles: 	[ui.elNode, ui.textNode].concat($A(ui.elNode.childNodes)), // Set the Handles		        isHandle: 	false,				type:		stencil.id(),			// Set Type of stencil 				namespace:	stencil.namespace()		// Set Namespace of stencil				});									},		drop: function(option, shape, event) {				var commandClass = ORYX.Core.Command.extend({			construct: function(option, shape, position, plugin){				this.option = option;				this.position = position;				this.element = shape;				this.plugin = plugin;				this.facade = plugin.facade;				this.selection = this.facade.getSelection();				this.adjustChild;				this.shape;				this.parent;			},						execute: function(){				if (!this.shape) {					this.shape 	= this.facade.createShape(option);					this.parent = this.shape.parent;				} else {					this.parent.add(this.shape);				}								/**				 * DO ATTACH				 */					if( option.canAttach &&  this.element instanceof ORYX.Core.Node && this.shape.dockers.length > 0){					// Get first docker					var docker = this.shape.dockers[0];					// Add to the same parent					if( this.element.parent instanceof ORYX.Core.Node ) {						this.element.parent.add( this.shape );					}					// Set docker position												docker.bounds.centerMoveTo( this.position );					docker.setDockedShape( this.element );				}				/**				 * DO Connect				 */					if( option.canConnectBetween &&  this.element instanceof ORYX.Core.Edge){					var from 	= this.element.getSource();					var to 		= this.element.getTarget();					var edge;					if (this.edge) {						edge = this.edge;						this.facade.getCanvas().add(this.edge);					} else {						edge = this.facade.createShape({							namespace	: this.element.getStencil().namespace(),							type		: this.element.getStencil().id()						});					}										var mid = {x:this.shape.bounds.width()/2,y:this.shape.bounds.height()/2};					var refTo = this.element.getDockers().last().referencePoint;										var segment = this.element.findSegment(this.shape.absoluteCenterXY());					var dockers = this.element.dockers.slice(this.element.dockers.indexOf(segment.toDocker), this.element.dockers.length-1);															this.element.getDockers().last().setDockedShape(this.shape);					this.element.getDockers().last().setReferencePoint(mid);										edge.getDockers().first().setDockedShape(this.shape);					edge.getDockers().first().setReferencePoint(mid);					edge.getDockers().last().setDockedShape(to);					edge.getDockers().last().setReferencePoint(refTo);										this.dockerPosition = this.element.getDockers().map(function(docker){ return docker.bounds.center() });														dockers.each(function(oldDocker){						var pos = oldDocker.bounds.center();						var docker = edge.createDocker(undefined, pos);						docker.bounds.centerMoveTo(pos);					}.bind(this))										dockers.each(function(docker){						this.element.removeDocker(docker);					}.bind(this));															var abs = this.shape.absoluteBounds();					var prevEdge = this.element.dockers.slice(1, this.element.dockers.length-1).any(function(docker){										return abs.isIncluded(docker.bounds.center(), 10);									})														var succEdge = edge.dockers.slice(1, edge.dockers.length-1).any(function(docker){										return abs.isIncluded(docker.bounds.center(), 10);									})														if (prevEdge){ this.plugin.doLayout(this.element) }					if (succEdge){ 						this.plugin.doLayout(edge) 					}										this.edge = edge;				}												// Update				this.facade.setSelection([this.shape]);								this.facade.getCanvas().update();								// Set the parents correctly				if (!this.adjustChild){					this.adjustChild = new ORYX.Core.EnsureChildCommand(this.facade, this.shape);				}				this.adjustChild.execute();								// Update				this.facade.updateSelection();							},						rollback: function(){				// Rollback adjustment of childs				this.adjustChild.rollback();								// Delete shape				this.facade.deleteShape(this.shape);								if (this.edge){										// Reset the dockers					this.removeAllDocker(this.element);					this.dockerPosition.each(function(pos, i){							if (i==0||i==this.dockerPosition.length-1){ return }											var docker = this.element.createDocker(undefined, pos);						docker.bounds.centerMoveTo(pos);					}.bind(this));										// Reset the last docker					this.element.getDockers().last().setDockedShape(this.edge.getTarget());					this.element.getDockers().last().setReferencePoint(this.edge.dockers.last().referencePoint);										// Remove the new edge					this.facade.deleteShape(this.edge);									}				this.facade.setSelection(this.selection.without(this.shape));				this.facade.getCanvas().update();				this.facade.updateSelection();							},						removeAllDocker: function(edge){				edge.dockers.slice(1, edge.dockers.length-1).each(function(docker){					edge.removeDocker(docker);				})			}		});									var position = this.facade.eventCoordinates( event.browserEvent );			var command = new commandClass(option, shape, position, this);		this.facade.executeCommands([command]);				this._currentParent = undefined;	}	}ORYX.Plugins.ShapeRepository = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.ShapeRepository);