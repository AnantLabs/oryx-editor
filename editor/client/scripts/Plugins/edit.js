/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.Edit = {    facade: undefined,        construct: function(facade){            this.facade = facade;        this.copyElements = [];                //this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keyHandler.bind(this));                this.facade.offer({         name: ORYX.I18N.Edit.cut,         description: ORYX.I18N.Edit.cutDesc,         icon: ORYX.PATH + "images/cut.png",		 keyCodes: [{				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 88,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN			}		 ],         functionality: this.editCut.bind(this),         group: ORYX.I18N.Edit.group,         index: 1,         minShape: 1         });                 this.facade.offer({         name: ORYX.I18N.Edit.copy,         description: ORYX.I18N.Edit.copyDesc,         icon: ORYX.PATH + "images/page_copy.png",		 keyCodes: [{				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 67,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN			}		 ],         functionality: this.editCopy.bind(this),         group: ORYX.I18N.Edit.group,         index: 2,         minShape: 1         });                 this.facade.offer({         name: ORYX.I18N.Edit.paste,         description: ORYX.I18N.Edit.pasteDesc,         icon: ORYX.PATH + "images/page_paste.png",		 keyCodes: [{				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 86,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN			}		 ],         functionality: this.editPaste.bind(this),         isEnabled: this.clipboardIsOccupied.bind(this),         group: ORYX.I18N.Edit.group,         index: 3,         minShape: 0,         maxShape: 0         });                 this.facade.offer({            name: ORYX.I18N.Edit.del,            description: ORYX.I18N.Edit.delDesc,            icon: ORYX.PATH + "images/cross.png",			keyCodes: [{					metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],					keyCode: 8,					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN				},				{						keyCode: 46,					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN				}			],            functionality: this.editDelete.bind(this),            group: ORYX.I18N.Edit.group,            index: 4,            minShape: 1        });                 /* What is the purpose of this?!		 this.facade.offer({         name: "Show Clipboard",         description: "Show Clipboard.",         icon: ORYX.PATH + "images/box.png",         functionality: this.showClipboard.bind(this),         group: "Edit",         index: 5         });         */    },			/**	 * Handles the mouse down event and starts the copy-move-paste action, if	 * control or meta key is pressed.	 */	handleMouseDown: function(event) {		if(this._controlPressed) {			this._controlPressed = false;			this.editCopy();			console.log("copiedEle: %0",this.copyElements)			console.log("mousevent: %o",event)			this.editPaste();			event.forceExecution = true;			this.facade.raiseEvent(event, this.copyElements);					}	},        /**     * Determines whether the clipboard currently is occupied.     */    clipboardIsOccupied: function(){        return this.copyElements.length > 0;    },        showClipboard: function(){            Ext.Msg.alert("Oryx", this.inspect(this.copyElements, true, 3));    },        inspect: function(toInspect, ignoreFunctions, depth){            if (depth-- <= 0)             return toInspect;                var temp = "";        for (key in toInspect) {                    var current = toInspect[key];                        if (ignoreFunctions && (current instanceof Function))                 continue;                        temp += key + ": (" + this.inspect(current, ignoreFunctions, depth) +            ") -";        }                if (temp == "")             return toInspect;        else             return temp;    },	    /**     * The key handler for this plugin. Every action from the set of cut, copy,     * paste and delete should be accessible trough simple keyboard shortcuts.     * This method checks whether any event triggers one of those actions.     *     * @param {Object} event The keyboard event that should be analysed for     *     triggering of this plugin.     *///    keyHandler: function(event){//        //TODO document what event.which is.//        //        ORYX.Log.debug("edit.js handles a keyEvent.");//        //        // assure we have the current event.//        if (!event) //            event = window.event;//        //        //        // get the currently pressed key and state of control key.//        var pressedKey = event.which || event.keyCode;//        var ctrlPressed = event.ctrlKey;//        //        // if the object is to be deleted, do so, and return immediately.//        if ((pressedKey == ORYX.CONFIG.KEY_CODE_DELETE) ||//        ((pressedKey == ORYX.CONFIG.KEY_CODE_BACKSPACE) &&//        (event.metaKey || event.appleMetaKey))) {//        //            ORYX.Log.debug("edit.js deletes the shape.");//            this.editDelete();//            return;//        }//        //         // if control key is not pressed, we're not interested anymore.//         if (!ctrlPressed)//         return;//         //         // when ctrl is pressed, switch trough the possibilities.//         switch (pressedKey) {//         //	         // cut.//	         case ORYX.CONFIG.KEY_CODE_X://	         this.editCut();//	         break;//	         //	         // copy.//	         case ORYX.CONFIG.KEY_CODE_C://	         this.editCopy();//	         break;//	         //	         // paste.//	         case ORYX.CONFIG.KEY_CODE_V://	         this.editPaste();//	         break;//         }//    },	    /**     * Returns a list of shapes which should be considered while copying.     * Besides the shapes of given ones, edges and attached nodes are added to the result set.     * If one of the given shape is a child of another given shape, it is not put into the result.      */    getAllShapesToConsider: function(shapes){        var shapesToConsider = []; // only top-level shapes        var allShapesToConsider = []; // all shapes including children                shapes.each(function(shape){            //Throw away these shapes which have a parent in given shapes            isChildShapeOfAnother = shapes.any(function(s2){                return s2.hasChildShape(shape);            });            if(isChildShapeOfAnother) return;                        // This shape should be considered            shapesToConsider.push(shape);            // Consider attached nodes (e.g. intermediate events)            if (shape instanceof ORYX.Core.Node) {                shapesToConsider = shapesToConsider.concat(shape.getOutgoingNodes());            }                        allShapesToConsider = allShapesToConsider.concat(shape.getChildShapes(true), shapesToConsider);        }.bind(this));                // All edges between considered shapes should be considered        // Look for these edges having incoming and outgoing in allShapesToConsider        var edgesToConsider = this.facade.getCanvas().getChildEdges().select(function(edge){            return edge.getAllDockedShapes().all(function(shape){                return allShapesToConsider.include(shape);            });        });        shapesToConsider = shapesToConsider.concat(edgesToConsider);                return shapesToConsider;    },        /**     * Performs the cut operation by first copy-ing and then deleting the     * current selection.     */    editCut: function(){        //TODO document why this returns false.        //TODO document what the magic boolean parameters are supposed to do.                this.editCopy(false);        this.editDelete(true);        return false;    },        /**     * Performs the copy operation.     * @param {Object} will_not_update ??     */    editCopy: function( will_update ){		var selection = this.facade.getSelection();				//if the selection is empty, do not remove the previously copied elements		if(selection.length == 0) return;		this.copyElements = this.getAllShapesToConsider(selection);		        if( will_update ) this.facade.updateSelection();    },        /**     * Performs the paste operation.     */    editPaste: function(){        // Create a new canvas with childShapes        var canvas = {            childShapes: this.copyElements.map(function(shape){return shape.toJSON()})        }                // Apply json helper to iterate over json object        Ext.apply(canvas, ORYX.Core.AbstractShape.JSONHelper);                var childShapeResourceIds = canvas.getChildShapes(true).pluck("resourceId");                canvas.eachChild(function(shape, parent){            if(shape.getShape() instanceof ORYX.Core.Node) {                // Move the shape occording to COPY_MOVE_OFFSET                shape.bounds = {                    lowerRight: {                        x: shape.bounds.lowerRight.x + ORYX.CONFIG.COPY_MOVE_OFFSET,                        y: shape.bounds.lowerRight.y + ORYX.CONFIG.COPY_MOVE_OFFSET                    },                    upperLeft: {                        x: shape.bounds.upperLeft.x + ORYX.CONFIG.COPY_MOVE_OFFSET,                        y: shape.bounds.upperLeft.y + ORYX.CONFIG.COPY_MOVE_OFFSET                    }                };                                shape.dockers = shape.dockers.map(function(docker){                    return {                        x: docker.x + ORYX.CONFIG.COPY_MOVE_OFFSET,                         y: docker.y + ORYX.CONFIG.COPY_MOVE_OFFSET                    };                });            }                        // Throw away these outgoings where the referenced shape isn't copied            if(shape.outgoing){                shape.outgoing = shape.outgoing.select(function(out){                    return childShapeResourceIds.include(out.resourceId);                });            }                        return shape;        }, false, true);                this.facade.importJSON(canvas);    },        /**     * Performs the delete operation. No more asking.     */    editDelete: function(){		var commandClass = ORYX.Core.Command.extend({			construct: function(selectedShapes, shapes, facade){				this.selectedShapes		= selectedShapes;				this.facade				= facade;				this.shapes				= shapes;                // Store parents of deleted shapes                this.parents            = new Hash();                // Store dockers of deleted shapes to restore connections                this.dockers            = [];			},						execute: function(){				this.shapes.each(function(shape){                    // Store parent and index in parent's childShapes for rollback                    var parent = shape.getParentShape() || this.facade.getCanvas();                    this.parents[shape.resourceId] = {                        object: parent,                        index: parent.getChildShapes().indexOf(shape)                    };                                        // Store dockers for rollback                    var incomingDockers = shape.getIncomingShapes().map(function(s){return s.getDockers().last()})                    var outgoingDockers = shape.getOutgoingShapes().map(function(s){return s.getDockers().first()})                    var dockers = shape.getDockers().concat(incomingDockers, outgoingDockers).compact().map(function(docker){                        return {                            object: docker,                            referencePoint: docker.referencePoint,                            dockedShape: docker.getDockedShape()                        };                    });                    this.dockers = this.dockers.concat(dockers);                                        // Delete shape					this.facade.deleteShape(shape);		        }.bind(this));								this.facade.getCanvas().update();								this.facade.setSelection([]);			},			rollback: function(){				this.shapes.each(function(shape) {					this.parents[shape.resourceId].object.add(shape, this.parents[shape.resourceId].index);				}.bind(this));								//reconnect shapes				this.dockers.each(function(d) {					d.object.setDockedShape(d.dockedShape);					d.object.setReferencePoint(d.referencePoint);				}.bind(this));								this.facade.getCanvas().update();								this.facade.setSelection(this.selectedShapes);			}		});		        var selection = this.facade.getSelection();        		var command = new commandClass(selection, 									   this.getAllShapesToConsider(selection),									   this.facade);                                       		this.facade.executeCommands([command]);    }}; ORYX.Plugins.Edit = Clazz.extend(ORYX.Plugins.Edit);