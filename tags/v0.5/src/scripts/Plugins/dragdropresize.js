/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.DragDropResize = Clazz.extend({	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		// Initialize variables		this.currentShapes = [];			// Current selected Shapes		this.pluginsData = [];				// Available Plugins		this.toMoveShapes = [];				// Shapes there will be moved		this.distPoints = [];				// Distance Points for Snap on Grid		this.isResizing = false;			// Flag: If there was currently resized		this.dragEnable = false;			// Flag: If Dragging is enabled		this.dragIntialized = false;		// Flag: If the Dragging is initialized		this.offSetPosition = {x: 0, y: 0};	// Offset of the Dragging		this.faktorXY = {x: 1, y: 1};		// The Current Zoom-Faktor		this.containmentParentNode;			// the current future parent node for the dragged shapes		this.isAddingAllowed = false;		// flag, if adding current selected shapes to containmentParentNode is allowed		this.isAttachingAllowed = false;	// flag, if attaching to the current shape is allowed				// Get the SVG-Containernode 		var containerNode = this.facade.getCanvas().getSvgContainer();				// Create the Selected Rectangle in the SVG		this.selectedRect = new ORYX.Plugins.SelectedRect(containerNode);				// Get a HTML-ContainerNode		containerNode = this.facade.getCanvas().getHTMLContainer();				// Create a Button for resize 		this.resizer = new ORYX.Plugins.Resizer(containerNode, this.facade.getCanvas().node);		// Registern the Resize-Callback		this.resizer.registerOnResize(this.onResize.bind(this));				// For the Drag and Drop		// Register on MouseDown-Event on a Shape		this.facade.registerOnEvent('mousedown', this.handleMouseDown.bind(this));		// Register on Global Mouse-UP/-MOVE Event		document.documentElement.addEventListener('mouseup', 	this.handleMouseUp.bind(this), 		true);		document.documentElement.addEventListener('mousemove', 	this.handleMouseMove.bind(this), 	false);		// Register the Custom-Events		this.facade.registerEventType('dragdrop.start');		this.facade.registerEventType('dragdrop.end');	},	/**	 * On Mouse Down	 *	 */	handleMouseDown: function(event, uiObj) {		// If the selection Bounds not intialized and the uiObj is not member of current selectio		// then return		if(!this.dragBounds || !this.currentShapes.member(uiObj)) {return};		// Start Dragging		this.dragEnable = true;		this.dragIntialized = true;		// Calculate the current zoom factor		var a = this.facade.getCanvas().node.getScreenCTM();		this.faktorXY.x = a.a;		this.faktorXY.y = a.d;		// Set the offset position of dragging		var upL = this.dragBounds.upperLeft();		this.offSetPosition =  {			x: Event.pointerX(event) - (upL.x * this.faktorXY.x),			y: Event.pointerY(event) - (upL.y * this.faktorXY.y)};		return;	},	/**	 * On Key Mouse Up	 *	 */	handleMouseUp: function(event) {		// If Resizing finished, the Shapes will be resize		if(this.isResizing) {			// Update the bounds off all shapes			var bounds = this.dragBounds;			this.currentShapes.each(function(value){				if(value.parent) {					var parentPosition = value.parent.absoluteXY();					bounds.moveBy(-parentPosition.x, -parentPosition.y);				}								value.bounds.set(bounds.a, bounds.b);				value.update();			});			this.facade.updateSelection();			this.isResizing = false;		}		//disable containment highlighting		this.facade.raiseEvent({									type:"highlight.hideHighlight",									highlightId:"dragdropresize.contain"								});										this.facade.raiseEvent({									type:"highlight.hideHighlight",									highlightId:"dragdropresize.attached"								});		// If Dragging is finished		if(this.dragEnable) {					// and update the current selection			if(!this.dragIntialized) {								// Do Method after Dragging				this.afterDrag();														if ( 	this.isAttachingAllowed &&						this.toMoveShapes.length == 1 && this.toMoveShapes[0] instanceof ORYX.Core.Node  &&						this.toMoveShapes[0].dockers.length > 0) {									//this.refreshSelectedShapes();															var position 	= this.facade.eventCoordinates( event );											var docker = this.toMoveShapes[0].dockers[0];					if( docker.parent instanceof ORYX.Core.Node ) {						this.containmentParentNode.parent.add( docker.parent );					}															docker.setDockedShape( undefined );					docker.bounds.centerMoveTo( position )									docker.setDockedShape( this.containmentParentNode );											//this.facade.getCanvas().update();														} else if( this.isAddingAllowed ) {										this.refreshSelectedShapes();										this.toMoveShapes.each((function(currentShape) {						if(currentShape instanceof ORYX.Core.Node &&						   currentShape.parent !== this.containmentParentNode) {							var unul = this.containmentParentNode.absoluteXY();							var csul = currentShape.absoluteXY();							var x = csul.x - unul.x;							var y = csul.y - unul.y;							this.containmentParentNode.add(currentShape);														currentShape.getOutgoingShapes((function(shape) {								if(shape instanceof ORYX.Core.Node && !this.toMoveShapes.member(shape)) {									this.containmentParentNode.add(shape);								}							}).bind(this));							currentShape.bounds.moveTo(x, y);						} 												currentShape.update();											}).bind(this));										//this.facade.getCanvas().update();				}								this.facade.updateSelection();											//this.currentShapes.each(function(shape) {shape.update()})				// Raise Event: Dragging is finished				this.facade.raiseEvent({type:'dragdrop.end'});			}				this.dragEnable = false;		}				return;	},	/**	* On Key Mouse Move	*	*/	handleMouseMove: function(event) {		// If dragging is not enabled, go return		if(!this.dragEnable) { return };		// If Dragging is initialized		if(this.dragIntialized) {			// Do method before Drag			this.beforeDrag();			// Raise Event: Drag will be started			this.facade.raiseEvent({type:'dragdrop.start'});			this.dragIntialized = false;			// And Hide the Resizer and the Highlighting			this.resizer.hide();						// if only edges are selected, containmentParentNode must be the canvas			this._onlyEdges = this.currentShapes.all(function(currentShape) {				return (currentShape instanceof ORYX.Core.Edge);			});			this._currentUnderlyingNodes = [];							}					// Calculate the new position		var position = {			x: Event.pointerX(event) - this.offSetPosition.x,			y: Event.pointerY(event) - this.offSetPosition.y}		// If not the Control-Key are pressed		var modifierKeyPressed = event.shiftKey || event.ctrlKey;		if(ORYX.CONFIG.GRID_ENABLED && !modifierKeyPressed) {			// Snap the current position to the nearest Snap-Point			position = this.snapToGrid(position);		}		// Adjust the point by the zoom faktor 		position.x /= this.faktorXY.x;		position.y /= this.faktorXY.y;		// Set that the position is not lower than zero		position.x = Math.max( 0 , position.x)		position.y = Math.max( 0 , position.y)		// Set that the position is not bigger than the canvas		var c = this.facade.getCanvas()		position.x = Math.min( c.bounds.width() - this.dragBounds.width(), 		position.x)		position.y = Math.min( c.bounds.height() - this.dragBounds.height(), 	position.y)									// Drag this bounds		this.dragBounds.moveTo(position);		// Update all selected shapes and the selection rectangle		//this.refreshSelectedShapes();		this.resizeRectangle(this.dragBounds);		this.isAttachingAllowed = false;		//check, if a node can be added to the underlying node		var underlyingNodes = $A(this.facade.getCanvas().getAbstractShapesAtPosition(this.facade.eventCoordinates(event)));				var checkIfAttachable = this.toMoveShapes.length == 1 && this.toMoveShapes[0] instanceof ORYX.Core.Node && this.toMoveShapes[0].dockers.length > 0		checkIfAttachable	= checkIfAttachable && underlyingNodes.length != 1					if(		!checkIfAttachable &&				underlyingNodes.length === this._currentUnderlyingNodes.length  &&				underlyingNodes.all(function(node, index){return this._currentUnderlyingNodes[index] === node}.bind(this))) {								return					} else if(this._onlyEdges) {						this.isAddingAllowed = true;			this.containmentParentNode = this.facade.getCanvas();					} else {					//get underlying node that is not the same than one of the currently selected shapes or			// a child of one of the selected shapes with the highest z Order.			// The result is a shape or the canvas			this.containmentParentNode = underlyingNodes.reverse().find((function(node) {				return (node instanceof ORYX.Core.Canvas) || ((node instanceof ORYX.Core.Node) && (!(this.currentShapes.member(node) || 																this.currentShapes.any(function(shape) {																	return (shape.getChildNodes(true).member(node));																}))));			}).bind(this));												if( checkIfAttachable ){									this.isAttachingAllowed	= this.facade.getRules().canConnect({													sourceShape:	this.containmentParentNode, 													edgeShape:		this.toMoveShapes[0], 													targetShape:	this.toMoveShapes[0]													});														if ( this.isAttachingAllowed	) {					this.isAttachingAllowed	= this.containmentParentNode.isPointOverOffset( this.facade.eventCoordinates(event) );				}									}						if( !this.isAttachingAllowed ){				//check all selected shapes, if they can be added to containmentParentNode				this.isAddingAllowed = this.toMoveShapes.all((function(currentShape) {					if(currentShape instanceof ORYX.Core.Edge ||						currentShape instanceof ORYX.Core.Controls.Docker ||						this.containmentParentNode === currentShape.parent) {						return true;					} else if(this.containmentParentNode !== currentShape) {												if(!(this.containmentParentNode instanceof ORYX.Core.Edge)) {							if(this.facade.getRules().canContain({containingShape:this.containmentParentNode,																  containedShape:currentShape})) {	  									return true;							}						}					}					return false;				}).bind(this));							}						}				this._currentUnderlyingNodes = underlyingNodes.reverse();				//visualize the containment result		if( this.isAttachingAllowed ) {						this.facade.raiseEvent({									type: 			"highlight.showHighlight",									highlightId: 	"dragdropresize.attached",									elements: 		[this.containmentParentNode],									style: 			ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,									color: 			ORYX.CONFIG.SELECTION_VALID_COLOR								});										} else {						this.facade.raiseEvent({									type:"highlight.hideHighlight",									highlightId:"dragdropresize.attached"								});		}				if( !this.isAttachingAllowed ){			if( this.isAddingAllowed ) {				this.facade.raiseEvent({										type:"highlight.showHighlight",										highlightId:"dragdropresize.contain",										elements:[this.containmentParentNode],										color: ORYX.CONFIG.SELECTION_VALID_COLOR									});			} else {				this.facade.raiseEvent({										type:"highlight.showHighlight",										highlightId:"dragdropresize.contain",										elements:[this.containmentParentNode],										color: ORYX.CONFIG.SELECTION_INVALID_COLOR									});			}					} else {			this.facade.raiseEvent({									type:"highlight.hideHighlight",									highlightId:"dragdropresize.contain"								});					}					// Stop the Event		Event.stop(event);		return;	},	/**	 * Callback for Resize	 *	 */	onResize: function(bounds) {		// If the selection bounds not initialized, return		if(!this.dragBounds) {return}				this.dragBounds = bounds;		this.isResizing = true;		// Update the rectangle 		this.resizeRectangle(this.dragBounds);	},	/**	 * Redraw the selected Shapes.	 *	 */	refreshSelectedShapes: function() {		// If the selection bounds not initialized, return		if(!this.dragBounds) {return}		// Calculate the offset between the bounds and the old bounds		var upL = this.dragBounds.upperLeft();		var oldUpL = this.oldDragBounds.upperLeft();		var offset = {			x: upL.x - oldUpL.x,			y: upL.y - oldUpL.y };		// Move all Shapes by these offset		this.toMoveShapes.each(function(value){			value.bounds.moveBy(offset);		});		// copy the bounds to the old bounds		this.oldDragBounds = this.dragBounds.clone();	},	/**	 * Prepare the Dragging	 *	 */	beforeDrag: function(){		// Get thru all Selected Shapes, and if there is an Shape who is docked on an		// Shape there is not in the selection, then undocked them from this shape.		this.toMoveShapes.each((function(uiObj) {			if(uiObj instanceof ORYX.Core.Controls.Docker){				uiObj.setDockedShape(undefined);			}						if(uiObj instanceof ORYX.Core.Node && uiObj.dockers.length > 0){				//uiObj.dockers.first().setDockedShape(undefined)			}		}).bind(this))						// Hide all closed-by labels		/*this.currentShapes.each((function(shape) {			this.hideAllLabels(shape);		}).bind(this));*/	},	hideAllLabels: function(shape) {						// Hide all labels from the shape			shape.getLabels().each(function(label) {				label.hide();			});			// Hide all labels from docked shapes			shape.getAllDockedShapes().each(function(dockedShape) {				var labels = dockedShape.getLabels();				if(labels.length > 0) {					labels.each(function(label) {						label.hide();					});				}			});			// Do this recursive for all child shapes			// EXP-NICO use getShapes			shape.getChildren().each((function(value) {				if(value instanceof ORYX.Core.Shape)					this.hideAllLabels(value);			}).bind(this));	},	/**	 * Finished the Dragging	 *	 */	afterDrag: function(){		// Show all closed-by labels		/*this.currentShapes.each((function(shape) {			this.showAllLabels(shape);		}).bind(this));*/						this.toMoveShapes.each((function(uiObj) {				if(	uiObj instanceof ORYX.Core.Node && uiObj.dockers.length > 0 &&  this.isAddingAllowed){				uiObj.dockers.first().setDockedShape(undefined)			}		}).bind(this))					},	/**	 * Show all Labels at these shape	 * 	 */	showAllLabels: function(shape) {			// Show the label of these shape			shape.getLabels().each(function(label) {				label.show();			});			// Show all labels at docked shapes			shape.getAllDockedShapes().each(function(dockedShape) {				var labels = dockedShape.getLabels();				if(labels.length > 0) {					labels.each(function(label) {						label.show();					});				}			});			// Do this recursive			shape.children.each((function(value) {				if(value instanceof ORYX.Core.Shape)					this.showAllLabels(value);			}).bind(this));	},	/**	 * Intialize Method, if there are new Plugins	 *	 */	registryChanged: function(pluginsData) {		// Save all new Plugin, sorted by group and index		this.pluginsData = pluginsData.sortBy( function(value) {			return (value.group + "" + value.index);		});	},	/**	 * On the Selection-Changed	 *	 */	onSelectionChanged: function(event) {		var elements = event.elements;				// Reset the drag-variables		this.dragEnable = false;		this.dragIntialized = false;		this.resizer.hide();		// If there is no elements		if(!elements || elements.length == 0) {			// Hide all things and reset all variables			this.selectedRect.hide();			this.currentShapes = [];			this.toMoveShapes = [];			this.dragBounds = undefined;			this.oldDragBounds = undefined;		} else {			// Set the current Shapes			this.currentShapes = elements;			// Get all shapes with the highest parent in object hierarchy (canvas is the top most parent)			this.toMoveShapes = this.facade.getCanvas().getShapesWithSharedParent(elements);						this.toMoveShapes = this.toMoveShapes.findAll( function(shape) { return shape instanceof ORYX.Core.Node && 																			(shape.dockers.length === 0 || !elements.member(shape.dockers.first().getDockedShape()))});																								elements.each((function(shape){				if(!(shape instanceof ORYX.Core.Edge)) {return}												var hasF = elements.member(shape.getDockers().first().getDockedShape());				var hasL = elements.member(shape.getDockers().last().getDockedShape());											if(!hasL) {					this.toMoveShapes.push(shape.dockers.last());				}				if(!hasF){					this.toMoveShapes.push(shape.dockers.first())				} 							}).bind(this));						// Calculate the new area-bounds of the selection			var newBounds = undefined;			elements.each(function(value) {				if(!newBounds)					newBounds = value.absoluteBounds();				else					newBounds.include(value.absoluteBounds());			});			// Set the new bounds			this.dragBounds = newBounds;			this.oldDragBounds = newBounds.clone();			// Update and show the rectangle			this.resizeRectangle(newBounds);			this.selectedRect.show();						// Show the resize button, if there is only one element and this is resizeable			if(elements.length == 1 && elements[0].isResizable) {				this.resizer.setBounds(this.dragBounds, elements[0].minimumSize,  elements[0].maximumSize);				this.resizer.show();			} else {				this.resizer.setBounds(undefined);			}			// If Snap-To-Grid is enabled, the Snap-Point will be calculate			if(ORYX.CONFIG.GRID_ENABLED) {				// Reset all points				this.distPoints = [];				// Get all the shapes, there will consider at snapping				var distShapes = this.facade.getCanvas().getChildNodes(true);				// The current selection will delete from this array				elements.each(function(shape) {					distShapes = distShapes.without(shape);				});				// For all these shapes				distShapes.each((function(value) {					if(!(value instanceof ORYX.Core.Edge)) {						var ul = value.absoluteXY();						var width = value.bounds.width();						var height = value.bounds.height();						// Add the upperLeft, center and lowerRight - Point to the distancePoints						this.distPoints.push({x:ul.x, y:ul.y});						this.distPoints.push({x:ul.x+Math.round(width/2), y:ul.y+Math.round(height/2)});						this.distPoints.push({x:ul.x+width, y:ul.y+height});					}				}).bind(this));				// Add all the Point from the Grid to the distance Points				var distC = Math.max(this.facade.getCanvas().bounds.width(), this.facade.getCanvas().bounds.height());				for(i = 0; i < distC; i = i + ORYX.CONFIG.GRID_DISTANCE) {					this.distPoints.push({x:i, y:i});				}			}		}	},	/**	 * Adjust an Point to the Snap Points	 *	 */	snapToGrid: function(position) {			// Get X / Y value			var x = position.x;			var y = position.y;			// Get the current Bounds			var bounds = this.dragBounds;			// Start Value			var distX = x - this.distPoints[0].x;			var distY = y - this.distPoints[0].y;			// Line adjust for Snapping lines			var lineX = 0;			var lineY = 0;			// For each distant point			this.distPoints.each(function(value) {				// calculate the y-distance value				var distY1 = y - value.y;				var distY2 = (y + Math.round(bounds.height()/2)) - value.y;				var distY3 = (y + bounds.height())  - value.y;				// Set the absolute min value to current value				if(Math.abs(distY1) < Math.abs(distY)) { distY = distY1; lineY = 0;}				if(Math.abs(distY2) < Math.abs(distY)) { distY = distY2; lineY = 1;}				if(Math.abs(distY3) < Math.abs(distY)) { distY = distY3; lineY = 2;}				// calculate the x-distance value				var distX1 = x - value.x;				var distX2 = (x + Math.round(bounds.width()/2)) - value.x;				var distX3 = (x + bounds.width())  - value.x;				// Set the absolute min value to current value				if(Math.abs(distX1) < Math.abs(distX)) { distX = distX1; lineX = 0;}				if(Math.abs(distX2) < Math.abs(distX)) { distX = distX2; lineX = 1;}				if(Math.abs(distX3) < Math.abs(distX)) { distX = distX3; lineX = 2;}			});			// calculate the y-line value			if(lineY == 1) {				lineY = (bounds.height()/2.0) ;			} else if(lineY == 2) {				lineY = bounds.height();			}			// calculate the x-line value			if(lineX == 1) {				lineX = (bounds.width()/2.0);			} else if(lineX == 2) {				lineX = bounds.width();			}			// Return the new values			return {				y: y - distY,				x: x - distX}	},	/**	 * Redraw of the Rectangle of the SelectedArea	 * @param {Object} bounds	 */	resizeRectangle: function(bounds) {		// Resize the Rectangle				this.selectedRect.resize(bounds);	}});ORYX.Plugins.SelectedRect = Clazz.extend({	construct: function(parentId) {		this.parentId = parentId;		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", $(parentId),					['g']);		this.dashedArea = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,			['rect', {x: 0, y: 0,				'stroke-width': 1, stroke: '#777777', fill: 'none',				'stroke-dasharray': '2,2',				'pointer-events': 'none'}]);		this.hide();	},	hide: function() {		this.node.setAttributeNS(null, 'display', 'none');	},	show: function() {		this.node.setAttributeNS(null, 'display', '');	},	resize: function(bounds) {		var upL = bounds.upperLeft();		var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;		this.dashedArea.setAttributeNS(null, 'width', bounds.width() + 2*padding);		this.dashedArea.setAttributeNS(null, 'height', bounds.height() + 2*padding);		this.node.setAttributeNS(null, 'transform', "translate("+ (upL.x - padding) +", "+ (upL.y - padding) +")");	}});ORYX.Plugins.Resizer = Clazz.extend({	construct: function(parentId, canvasNode) {		this.parentId = parentId;		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(this.parentId),			['div', {'class': 'resizer', style:'left:0px; top:0px;'}]);		this.node.addEventListener('mousedown', this.handleMouseDown.bind(this), true);		document.documentElement.addEventListener('mouseup', 	this.handleMouseUp.bind(this), 		true);		document.documentElement.addEventListener('mousemove', 	this.handleMouseMove.bind(this), 	false);		this.dragEnable = false;		this.offSetPosition = {x: 0, y: 0};		this.bounds = undefined;		this.canvasNode = canvasNode;		this.minSize = undefined;		this.maxSize = undefined;		this.resizeCallbacks = [];		this.hide();	},	handleMouseDown: function(event) {		this.dragEnable = true;		this.offSetPosition =  {			x: Event.pointerX(event) - this.position.x,			y: Event.pointerY(event) - this.position.y};	},	handleMouseUp: function(event) {		this.dragEnable = false;	},	handleMouseMove: function(event) {		if(!this.dragEnable) { return}		var position = {			x: Event.pointerX(event) - this.offSetPosition.x,			y: Event.pointerY(event) - this.offSetPosition.y}		var offset = {			x: position.x - this.position.x,			y: position.y - this.position.y		}		if(offset.x < 0 && Math.abs(offset.x) > this.bounds.width())			offset.x = this.minSize.width - this.bounds.width();		if(offset.y < 0 && Math.abs(offset.y) > this.bounds.height())			offset.y = this.minSize.height - this.bounds.height();		this.bounds.extend(offset);		this.update();		this.resizeCallbacks.each((function(value) {			value(this.bounds);		}).bind(this));		Event.stop(event);	},	registerOnResize: function(callback) {		if(!this.resizeCallbacks.member(callback)) {			this.resizeCallbacks.push(callback);		}	},	unregisterOnResize: function(callback) {		if(this.resizeCallbacks.member(callback)) {			this.resizeCallbacks = this.resizeCallbacks.without(callback);		}	},	hide: function() {		this.node.style.display = "none";	},	show: function() {		if(this.bounds)			this.node.style.display = "";	},	setBounds: function(bounds, min, max) {		this.bounds = bounds;		if(!min)			min = {width: ORYX.CONFIG.MINIMUM_SIZE, height: ORYX.CONFIG.MINIMUM_SIZE};		if(!max)			max = {width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE};		this.minSize = min;		this.maxSize = max;		this.update();	},	update: function() {		if(!this.bounds) { return; }		var upL = this.bounds.upperLeft();		if(this.bounds.width() < this.minSize.width)	{ this.bounds.set(upL.x, upL.y, upL.x + this.minSize.width, upL.y + this.bounds.height())};		if(this.bounds.height() < this.minSize.height)	{ this.bounds.set(upL.x, upL.y, upL.x + this.bounds.width(), upL.y + this.minSize.height)};		if(this.bounds.width() > this.maxSize.width)	{ this.bounds.set(upL.x, upL.y, upL.x + this.maxSize.width, upL.y + this.bounds.height())};		if(this.bounds.height() > this.maxSize.height)	{ this.bounds.set(upL.x, upL.y, upL.x + this.bounds.width(), upL.y + this.maxSize.height)};		var a = this.canvasNode.getScreenCTM();				upL.x *= a.a;		upL.y *= a.d;		upL.x +=  (a.a * this.bounds.width()) + 3 ;		upL.y +=  (a.d * this.bounds.height())  + 3;				this.position = upL;		this.node.style.left = this.position.x + "px";		this.node.style.top = this.position.y + "px";	}});