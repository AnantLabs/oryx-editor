/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}if(!ORYX.Core.Math) {ORYX.Core.Math = {};}	ORYX.Core.Math.midPoint = function(point1, point2) {	return 	{				x: (point1.x + point2.x) / 2.0,				y: (point1.y + point2.y) / 2.0			}}			/** * Get a boolean if the point is in the polygone * @param {point} * @param {line} Is a hashmap with point1, point2 * @param {offset} optional */ORYX.Core.Math.isPointInLine = function (point, line, offset) {	offset = offset ? Math.abs(offset) : 1;	var p1 = line.point1;	var p2 = line.point2;		if(p1.x == p2.x && Math.abs(point.x - p1.x) < offset && point.y < Math.max(p1.y, p2.y) && point.y > Math.min(p1.y, p2.y)) {		return true	}	if(p1.y == p2.y && Math.abs(point.y - p1.y) < offset && point.x < Math.max(p1.x, p2.x) && point.x > Math.min(p1.x, p2.x)) {		return true	}	if(point.x > Math.max(p1.x, p2.x) || point.x < Math.min(p1.x, p2.x)) {		return false	}	if(point.y > Math.max(p1.y, p2.y) || point.y < Math.min(p1.y, p2.y)) {		return false	}				var s = (p1.y - p2.y) / (p1.x - p2.x);		return 	Math.abs(point.y - ((s * point.x) + p1.y - s * p1.x)) < offset}/** * Get a boolean if the point is in the polygone * @param {point} * @param {elipse} Is a hashmap with x, y, radiusX, radiusY */ORYX.Core.Math.isPointInEllipse = function (point, elipse) {	if(!elipse.x || !elipse.y || !elipse.radiusX || !elipse.radiusY) {		throw "ORYX.Core.Math.isPointInEllipse needs a ellipse with these properties: x, y, radiusX, radiusY"	} 		return 	Math.sqrt(						(Math.pow(point.x - elipse.x, 2) / Math.pow(elipse.radiusX, 2)) 					+ 	(Math.pow(point.y - elipse.y, 2) / Math.pow(elipse.radiusY, 2))					 ) <= 1}	/** * Get a boolean if the point is in the polygone * @param {point} * @param {[points]} Cornerpoints of the Polygone */ORYX.Core.Math.isPointInPolygone = function (point, polygone) {		if(arguments.length != 2) { throw "ORYX.Core.Math.isPointInPolygone needs two arguments" }		var points = polygone;			if(polygone.first() != polygone.last())		polygone.push(polygone.first());							  	var angle = ORYX.Core.Math.arcTan2ofPoints(		polygone.first().x,		polygone.first().y,        point.x,		point.y,		polygone.last().x,		polygone.last().y);	for(var i = 0; i <= polygone.length - 2; i++) {		angle = angle + ORYX.Core.Math.arcTan2ofPoints(			polygone[i].x,			polygone[i].y,	        point.x,			point.y,			polygone[i+1].x,			polygone[i+1].y);	}		 	return Math.abs(angle) > 0.000001;}	/** * Calculates the dot product */ORYX.Core.Math.dotProduct = function(ax, ay, bx, by, cx, cy){  	return ((ax - bx) * (cx - bx)) + ((ay - by) * (cy - by));}/** * Calculates the cross product */ORYX.Core.Math.crossProduct = function(ax, ay, bx, by, cx, cy){  	return ((ax - bx) * (cy - by)) - ((ay - by) * (cx - bx));	}	/** * Calculates the arc tangens of three points */ORYX.Core.Math.arcTan2ofPoints = function (ax, ay, bx, by, cx, cy) {	return Math.atan2(ORYX.Core.Math.crossProduct(ax,ay,bx,by,cx,cy),ORYX.Core.Math.dotProduct(ax,ay,bx,by,cx,cy));}